import lal
import lalsimulation
import numpy as np
import pytest
import torch
from astropy import units as u
from torch.distributions import Uniform

import ml4gw.waveforms as waveforms


@pytest.fixture(params=[256, 1024, 2048])
def sample_rate(request):
    return request.param


@pytest.fixture()
def chirp_mass(request):
    dist = Uniform(5, 100)
    return dist.sample((100,))


@pytest.fixture()
def mass_ratio():
    dist = Uniform(0.125, 0.99)
    return dist.sample((100,))


@pytest.fixture()
def a_1(request):
    dist = Uniform(0, 0.90)
    return dist.sample((100,))


@pytest.fixture()
def a_2(request):
    dist = Uniform(0, 0.90)
    return dist.sample((100,))


@pytest.fixture()
def tilt_1(request):
    dist = Uniform(0, torch.pi)
    return dist.sample((100,))


@pytest.fixture()
def tilt_2(request):
    dist = Uniform(0, torch.pi)
    return dist.sample((100,))


@pytest.fixture()
def phi_12(request):
    dist = Uniform(0, 2 * torch.pi)
    return dist.sample((100,))


@pytest.fixture()
def phi_jl(request):
    dist = Uniform(0, 2 * torch.pi)
    return dist.sample((100,))


@pytest.fixture()
def distance(request):
    dist = Uniform(100, 3000)
    return dist.sample((100,))


@pytest.fixture()
def theta_jn(request):
    dist = Uniform(0, torch.pi)
    return dist.sample((100,))


@pytest.fixture()
def phase(request):
    dist = Uniform(0, 2 * torch.pi)
    return dist.sample((100,))


@pytest.fixture()
def chi_1(request):
    dist = Uniform(-0.999, 0.999)
    return dist.sample((100,))


@pytest.fixture()
def chi_2(request):
    dist = Uniform(-0.999, 0.999)
    return dist.sample((100,))


@pytest.fixture(params=[20, 40])
def f_ref(request):
    return request.param


def test_taylor_f2(
    chirp_mass,
    mass_ratio,
    chi_1,
    chi_2,
    phase,
    distance,
    f_ref,
    theta_jn,
    sample_rate,
):
    mass_2 = chirp_mass * (1 + mass_ratio) ** 0.2 / mass_ratio**0.6
    mass_1 = mass_ratio * mass_2

    # compare each waveform with lalsimulation
    for i in range(len(chirp_mass)):

        # construct lalinference params
        params = dict(
            m1=mass_1[i].item() * lal.MSUN_SI,
            m2=mass_2[i].item() * lal.MSUN_SI,
            S1x=0,
            S1y=0,
            S1z=chi_1[i].item(),
            S2x=0,
            S2y=0,
            S2z=chi_2[i].item(),
            distance=(distance[i].item() * u.Mpc).to("m").value,
            inclination=theta_jn[i].item(),
            phiRef=phase[i].item(),
            longAscNodes=0.0,
            eccentricity=0.0,
            meanPerAno=0.0,
            deltaF=1.0 / sample_rate,
            f_min=20,
            f_ref=f_ref,
            f_max=300,
            approximant=lalsimulation.TaylorF2,
            LALpars=lal.CreateDict(),
        )
        hp_lal, hc_lal = lalsimulation.SimInspiralChooseFDWaveform(**params)

        # reconstruct frequencies generated by
        # lal and filter based on fmin and fmax
        lal_freqs = np.array(
            [
                hp_lal.f0 + ii * hp_lal.deltaF
                for ii in range(len(hp_lal.data.data))
            ]
        )

        lal_mask = (lal_freqs > params["f_min"]) & (
            lal_freqs < params["f_max"]
        )

        lal_freqs = lal_freqs[lal_mask]
        torch_freqs = torch.tensor(lal_freqs, dtype=torch.float64)

        # generate waveforms using ml4gw
        hc_ml4gw, hp_ml4gw = waveforms.TaylorF2()(
            torch_freqs,
            chirp_mass[i][None],
            mass_ratio[i][None],
            chi_1[i][None],
            chi_2[i][None],
            distance[i][None],
            phase[i][None],
            theta_jn[i][None],
            f_ref,
        )

        hc_ml4gw = hc_ml4gw[0]
        hp_ml4gw = hp_ml4gw[0]

        hp_lal_data = hp_lal.data.data[lal_mask]
        hc_lal_data = hc_lal.data.data[lal_mask]

        # ensure no nans
        assert not torch.any(torch.isnan(hc_ml4gw))
        assert not torch.any(torch.isnan(hp_ml4gw))

        assert np.allclose(
            1e21 * hp_lal_data.real, 1e21 * hp_ml4gw.real.numpy(), atol=1e-3
        )
        assert np.allclose(
            1e21 * hp_lal_data.imag, 1e21 * hp_ml4gw.imag.numpy(), atol=1e-3
        )
        assert np.allclose(
            1e21 * hc_lal_data.real, 1e21 * hc_ml4gw.real.numpy(), atol=1e-3
        )
        assert np.allclose(
            1e21 * hc_lal_data.imag, 1e21 * hc_ml4gw.imag.numpy(), atol=1e-3
        )

        # taylor f2 is symmetric w.r.t m1 --> m2 flip.
        # so test that the waveforms are the same when m1 and m2
        # (and corresponding chi_1, chi_2 are flipped)
        # are flipped this can be done by flipping mass ratio
        hc_ml4gw, hp_ml4gw = waveforms.TaylorF2()(
            torch_freqs,
            chirp_mass[i][None],
            1 / mass_ratio[i][None],
            chi_2[i][None],
            chi_1[i][None],
            distance[i][None],
            phase[i][None],
            theta_jn[i][None],
            f_ref,
        )

        hc_ml4gw = hc_ml4gw[0]
        hp_ml4gw = hp_ml4gw[0]

        assert np.allclose(
            1e21 * hp_lal_data.real, 1e21 * hp_ml4gw.real.numpy(), atol=1e-3
        )
        assert np.allclose(
            1e21 * hp_lal_data.imag, 1e21 * hp_ml4gw.imag.numpy(), atol=1e-3
        )
        assert np.allclose(
            1e21 * hc_lal_data.real, 1e21 * hc_ml4gw.real.numpy(), atol=1e-3
        )
        assert np.allclose(
            1e21 * hc_lal_data.imag, 1e21 * hc_ml4gw.imag.numpy(), atol=1e-3
        )


def test_phenom_d(
    chirp_mass,
    mass_ratio,
    chi_1,
    chi_2,
    distance,
    phase,
    theta_jn,
    sample_rate,
    f_ref,
):
    total_mass = chirp_mass * (1 + mass_ratio) ** 1.2 / mass_ratio**0.6
    mass_1 = total_mass / (1 + mass_ratio)
    mass_2 = mass_1 * mass_ratio

    # compare each waveform with lalsimulation
    for i in range(len(chirp_mass)):

        # construct lalinference params
        params = dict(
            m1=mass_1[i].item() * lal.MSUN_SI,
            m2=mass_2[i].item() * lal.MSUN_SI,
            S1x=0,
            S1y=0,
            S1z=chi_1[i].item(),
            S2x=0,
            S2y=0,
            S2z=chi_2[i].item(),
            distance=(distance[i].item() * u.Mpc).to("m").value,
            inclination=theta_jn[i].item(),
            phiRef=phase[i].item(),
            longAscNodes=0.0,
            eccentricity=0.0,
            meanPerAno=0.0,
            deltaF=1.0 / sample_rate,
            f_min=20,
            f_ref=f_ref,
            f_max=300,
            approximant=lalsimulation.IMRPhenomD,
            LALpars=lal.CreateDict(),
        )
        hp_lal, hc_lal = lalsimulation.SimInspiralChooseFDWaveform(**params)

        # reconstruct frequencies generated by
        # lal and filter based on fmin and fmax
        lal_freqs = np.array(
            [
                hp_lal.f0 + ii * hp_lal.deltaF
                for ii in range(len(hp_lal.data.data))
            ]
        )

        lal_mask = (lal_freqs > params["f_min"]) & (
            lal_freqs < params["f_max"]
        )

        lal_freqs = lal_freqs[lal_mask]
        torch_freqs = torch.tensor(lal_freqs, dtype=torch.float32)

        # generate waveforms using ml4gw
        hc_ml4gw, hp_ml4gw = waveforms.IMRPhenomD()(
            torch_freqs,
            chirp_mass[i][None],
            mass_ratio[i][None],
            chi_1[i][None],
            chi_2[i][None],
            distance[i][None],
            phase[i][None],
            theta_jn[i][None],
            f_ref,
        )

        hc_ml4gw = hc_ml4gw[0]

        hp_ml4gw = hp_ml4gw[0]

        hp_lal_data = hp_lal.data.data[lal_mask]
        hc_lal_data = hc_lal.data.data[lal_mask]

        assert not torch.any(torch.isnan(hc_ml4gw))
        assert not torch.any(torch.isnan(hp_ml4gw))

        assert np.allclose(
            1e21 * hp_lal_data.real, 1e21 * hp_ml4gw.real.numpy(), atol=1e-3
        )
        assert np.allclose(
            1e21 * hp_lal_data.imag, 1e21 * hp_ml4gw.imag.numpy(), atol=1e-3
        )
        assert np.allclose(
            1e21 * hc_lal_data.real, 1e21 * hc_ml4gw.real.numpy(), atol=1e-3
        )
        assert np.allclose(
            1e21 * hc_lal_data.imag, 1e21 * hc_ml4gw.imag.numpy(), atol=1e-3
        )


def test_phenom_p():
    chirp_mass = torch.tensor([15.0, 30.0])
    mass_ratio = torch.tensor([0.99, 0.5])
    chi1z = torch.tensor([0.0, 0.5])
    chi2z = torch.tensor([-0.1, 0.1])
    distance = torch.tensor([100.0, 1000.0])
    sample_rate = 2048

    mass_2 = chirp_mass * (1 + mass_ratio) ** 0.2 / mass_ratio**0.6
    mass_1 = mass_2 * mass_ratio

    f_ref = 20.0
    phic = 0.0
    tc = 0.0
    inclination = 0.0

    for i in range(chirp_mass.shape[0]):
        m1, m2 = mass_1[i], mass_2[i]
        mr = mass_ratio[i]
        if m2 > m1:
            m1, m2 = m2, m1
            mr = 1 / mr

        params = dict(
            m1=m1.item() * lal.MSUN_SI,
            m2=m2.item() * lal.MSUN_SI,
            S1x=0,
            S1y=0,
            S1z=chi1z[i].item(),
            S2x=0,
            S2y=0,
            S2z=chi2z[i].item(),
            distance=(distance[i].item() * u.Mpc).to("m").value,
            inclination=inclination,
            phiRef=phic,
            longAscNodes=0.0,
            eccentricity=0.0,
            meanPerAno=0.0,
            deltaF=1.0 / sample_rate,
            f_min=10.0,
            f_ref=f_ref,
            f_max=300,
            approximant=lalsimulation.IMRPhenomPv2,
            LALpars=lal.CreateDict(),
        )
        hp_lal, hc_lal = lalsimulation.SimInspiralChooseFDWaveform(**params)

        # reconstruct frequencies generated by
        # lal and filter based on fmin and fmax
        lal_freqs = np.array(
            [
                hp_lal.f0 + ii * hp_lal.deltaF
                for ii in range(len(hp_lal.data.data))
            ]
        )

        lal_mask = (lal_freqs > params["f_min"]) & (
            lal_freqs < params["f_max"]
        )

        lal_freqs = lal_freqs[lal_mask]
        torch_freqs = torch.tensor(lal_freqs, dtype=torch.float32)

        hc_ml4gw, hp_ml4gw = waveforms.IMRPhenomPv2()(
            torch_freqs,
            chirp_mass[i][None],
            torch.tensor([mr]),
            torch.tensor([0.0]),
            torch.tensor([0.0]),
            chi1z[i][None],
            torch.tensor([0.0]),
            torch.tensor([0.0]),
            chi2z[i][None],
            distance[i][None],
            torch.tensor([phic]),
            torch.tensor([inclination]),
            f_ref,
            torch.tensor([tc]),
        )

        hp_ml4gw = hp_ml4gw[0]
        hc_ml4gw = hc_ml4gw[0]

        hp_lal_data = hp_lal.data.data[lal_mask]
        hc_lal_data = hc_lal.data.data[lal_mask]

        assert np.allclose(
            1e21 * hp_lal_data.real, 1e21 * hp_ml4gw.real.numpy(), atol=2e-3
        )
        assert np.allclose(
            1e21 * hp_lal_data.imag, 1e21 * hp_ml4gw.imag.numpy(), atol=2e-3
        )
        assert np.allclose(
            1e21 * hc_lal_data.real, 1e21 * hc_ml4gw.real.numpy(), atol=2e-3
        )
        assert np.allclose(
            1e21 * hc_lal_data.imag, 1e21 * hc_ml4gw.imag.numpy(), atol=2e-3
        )
