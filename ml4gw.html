<!DOCTYPE html>
<html class="writer-html5" lang="python" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ml4gw package &mdash; ml4gw  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=d048f138"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ml4gw.dataloading package" href="ml4gw.dataloading.html" />
    <link rel="prev" title="ml4gw" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            ml4gw
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">ml4gw</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">ml4gw package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ml4gw.dataloading.html">ml4gw.dataloading package</a></li>
<li class="toctree-l4"><a class="reference internal" href="ml4gw.nn.html">ml4gw.nn package</a></li>
<li class="toctree-l4"><a class="reference internal" href="ml4gw.transforms.html">ml4gw.transforms package</a></li>
<li class="toctree-l4"><a class="reference internal" href="ml4gw.waveforms.html">ml4gw.waveforms package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ml4gw.augmentations">ml4gw.augmentations module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.augmentations.SignalInverter"><code class="docutils literal notranslate"><span class="pre">SignalInverter</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.augmentations.SignalReverser"><code class="docutils literal notranslate"><span class="pre">SignalReverser</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-ml4gw.distributions">ml4gw.distributions module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.distributions.Cosine"><code class="docutils literal notranslate"><span class="pre">Cosine</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.distributions.DeltaFunction"><code class="docutils literal notranslate"><span class="pre">DeltaFunction</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.distributions.LogNormal"><code class="docutils literal notranslate"><span class="pre">LogNormal</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.distributions.LogUniform"><code class="docutils literal notranslate"><span class="pre">LogUniform</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.distributions.PowerLaw"><code class="docutils literal notranslate"><span class="pre">PowerLaw</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.distributions.RateEvolution"><code class="docutils literal notranslate"><span class="pre">RateEvolution</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.distributions.Sine"><code class="docutils literal notranslate"><span class="pre">Sine</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.distributions.UniformComovingVolume"><code class="docutils literal notranslate"><span class="pre">UniformComovingVolume</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-ml4gw.gw">ml4gw.gw module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.breathing"><code class="docutils literal notranslate"><span class="pre">breathing()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.compute_antenna_responses"><code class="docutils literal notranslate"><span class="pre">compute_antenna_responses()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.compute_ifo_snr"><code class="docutils literal notranslate"><span class="pre">compute_ifo_snr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.compute_network_snr"><code class="docutils literal notranslate"><span class="pre">compute_network_snr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.compute_observed_strain"><code class="docutils literal notranslate"><span class="pre">compute_observed_strain()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.cross"><code class="docutils literal notranslate"><span class="pre">cross()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.get_ifo_geometry"><code class="docutils literal notranslate"><span class="pre">get_ifo_geometry()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.outer"><code class="docutils literal notranslate"><span class="pre">outer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.plus"><code class="docutils literal notranslate"><span class="pre">plus()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.reweight_snrs"><code class="docutils literal notranslate"><span class="pre">reweight_snrs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.gw.shift_responses"><code class="docutils literal notranslate"><span class="pre">shift_responses()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-ml4gw.spectral">ml4gw.spectral module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.spectral.fast_spectral_density"><code class="docutils literal notranslate"><span class="pre">fast_spectral_density()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.spectral.median"><code class="docutils literal notranslate"><span class="pre">median()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.spectral.normalize_by_psd"><code class="docutils literal notranslate"><span class="pre">normalize_by_psd()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.spectral.spectral_density"><code class="docutils literal notranslate"><span class="pre">spectral_density()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.spectral.truncate_inverse_power_spectrum"><code class="docutils literal notranslate"><span class="pre">truncate_inverse_power_spectrum()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ml4gw.spectral.whiten"><code class="docutils literal notranslate"><span class="pre">whiten()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-ml4gw.types">ml4gw.types module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-ml4gw">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ml4gw</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">ml4gw</a></li>
      <li class="breadcrumb-item active">ml4gw package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/ml4gw.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ml4gw-package">
<h1>ml4gw package<a class="headerlink" href="#ml4gw-package" title="Link to this heading"></a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="ml4gw.dataloading.html">ml4gw.dataloading package</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml4gw.nn.html">ml4gw.nn package</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml4gw.transforms.html">ml4gw.transforms package</a></li>
<li class="toctree-l1"><a class="reference internal" href="ml4gw.waveforms.html">ml4gw.waveforms package</a></li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-ml4gw.augmentations">
<span id="ml4gw-augmentations-module"></span><h2>ml4gw.augmentations module<a class="headerlink" href="#module-ml4gw.augmentations" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.augmentations.SignalInverter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.augmentations.</span></span><span class="sig-name descname"><span class="pre">SignalInverter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.augmentations.SignalInverter" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Takes a tensor of timeseries of arbitrary dimension
and randomly inverts i.e. <span class="math notranslate nohighlight">\(h(t) \rightarrow -h(t)\)</span>
each timeseries with probability <code class="docutils literal notranslate"><span class="pre">prob</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prob</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Probability that a timeseries is inverted</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ml4gw.augmentations.SignalInverter.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.augmentations.SignalInverter.forward" title="Link to this definition"></a></dt>
<dd><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.
:rtype: <span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'*batch</span> <span class="pre">time']</span></code></span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.augmentations.SignalReverser">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.augmentations.</span></span><span class="sig-name descname"><span class="pre">SignalReverser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.augmentations.SignalReverser" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Takes a tensor of timeseries of arbitrary dimension
and randomly reverses i.e., <span class="math notranslate nohighlight">\(h(t) \rightarrow h(-t)\)</span>.
each timeseries with probability <code class="docutils literal notranslate"><span class="pre">prob</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prob</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Probability that a kernel is reversed</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="ml4gw.augmentations.SignalReverser.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.augmentations.SignalReverser.forward" title="Link to this definition"></a></dt>
<dd><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.
:rtype: <span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'*batch</span> <span class="pre">time']</span></code></span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="module-ml4gw.distributions">
<span id="ml4gw-distributions-module"></span><h2>ml4gw.distributions module<a class="headerlink" href="#module-ml4gw.distributions" title="Link to this heading"></a></h2>
<p>Module containing callables classes for generating samples
from specified distributions. Each callable should map from
an integer <code class="docutils literal notranslate"><span class="pre">N</span></code> to a 1D torch <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> containing <code class="docutils literal notranslate"><span class="pre">N</span></code> samples
from the corresponding distribution.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.distributions.Cosine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.distributions.</span></span><span class="sig-name descname"><span class="pre">Cosine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1.5707963267948966</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5707963267948966</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.Cosine" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></p>
<p>Cosine distribution based on
<code class="docutils literal notranslate"><span class="pre">torch.distributions.TransformedDistribution</span></code>
(see <a class="reference external" href="https://docs.pytorch.org/docs/stable/distributions.html#transformeddistribution">documentation</a>).</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ml4gw.distributions.Cosine.arg_constraints">
<span class="sig-name descname"><span class="pre">arg_constraints</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#ml4gw.distributions.Cosine.arg_constraints" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ml4gw.distributions.Cosine.log_prob">
<span class="sig-name descname"><span class="pre">log_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.Cosine.log_prob" title="Link to this definition"></a></dt>
<dd><p>Returns the log of the probability density/mass function evaluated at
<cite>value</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'']</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ml4gw.distributions.Cosine.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.Cosine.rsample" title="Link to this definition"></a></dt>
<dd><p>Generates a sample_shape shaped reparameterized sample or sample_shape
shaped batch of reparameterized samples if the distribution parameters
are batched.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.distributions.DeltaFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.distributions.</span></span><span class="sig-name descname"><span class="pre">DeltaFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">peak</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.DeltaFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ml4gw.distributions.DeltaFunction.arg_constraints">
<span class="sig-name descname"><span class="pre">arg_constraints</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#ml4gw.distributions.DeltaFunction.arg_constraints" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ml4gw.distributions.DeltaFunction.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.DeltaFunction.rsample" title="Link to this definition"></a></dt>
<dd><p>Generates a sample_shape shaped reparameterized sample or sample_shape
shaped batch of reparameterized samples if the distribution parameters
are batched.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.distributions.LogNormal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.distributions.</span></span><span class="sig-name descname"><span class="pre">LogNormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mean</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.LogNormal" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">LogNormal</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="ml4gw.distributions.LogNormal.support">
<span class="sig-name descname"><span class="pre">support</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.LogNormal.support" title="Link to this definition"></a></dt>
<dd><p>Constrain to a real half line <cite>(lower_bound, inf]</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.distributions.LogUniform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.distributions.</span></span><span class="sig-name descname"><span class="pre">LogUniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.LogUniform" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedDistribution</span></code></p>
<p>Sample from a log uniform distribution</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.distributions.PowerLaw">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.distributions.</span></span><span class="sig-name descname"><span class="pre">PowerLaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minimum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.PowerLaw" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedDistribution</span></code></p>
<p>Sample from a power law distribution,</p>
<div class="math notranslate nohighlight">
\[p(x) \approx x^{\alpha}.\]</div>
<p>Index alpha cannot be 0, since it is equivalent to a Uniform distribution.
This could be used, for example, as a universal distribution of
signal-to-noise ratios (SNRs) from uniformly volume distributed
sources</p>
<div class="math notranslate nohighlight">
\[p(\rho) = 3\;\rho_0^3 / \rho^4\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_0\)</span> is a representative minimum SNR
considered for detection. See, for example,
<a class="reference external" href="https://arxiv.org/abs/1102.5421">Schutz (2011)</a>.
Or, for example, <code class="docutils literal notranslate"><span class="pre">index=2</span></code> for uniform in Euclidean volume.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ml4gw.distributions.PowerLaw.support">
<span class="sig-name descname"><span class="pre">support</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">GreaterThanEq(lower_bound=0.0)</span></em><a class="headerlink" href="#ml4gw.distributions.PowerLaw.support" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.distributions.RateEvolution">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.distributions.</span></span><span class="sig-name descname"><span class="pre">RateEvolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rate_function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.RateEvolution" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#ml4gw.distributions.UniformComovingVolume" title="ml4gw.distributions.UniformComovingVolume"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniformComovingVolume</span></code></a></p>
<p>Wrapper around <a class="reference internal" href="#ml4gw.distributions.UniformComovingVolume" title="ml4gw.distributions.UniformComovingVolume"><code class="xref py py-meth docutils literal notranslate"><span class="pre">UniformComovingVolume()</span></code></a> to allow for
arbitrary rate evolution functions. E.g., if
<code class="docutils literal notranslate"><span class="pre">rate_function</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">z:</span> <span class="pre">1</span> <span class="pre">/</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">z)</span></code>, then the distribution
will sample values such that they occur uniform in
source frame time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rate_function</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></span>) -- Callable that takes redshift as input
and returns the rate evolution factor.</p></li>
<li><p><strong>*args</strong> -- Arguments passed to
<a class="reference internal" href="#ml4gw.distributions.UniformComovingVolume" title="ml4gw.distributions.UniformComovingVolume"><code class="xref py py-meth docutils literal notranslate"><span class="pre">UniformComovingVolume()</span></code></a> constructor.</p></li>
<li><p><strong>**kwargs</strong> -- Keyword arguments passed to
<a class="reference internal" href="#ml4gw.distributions.UniformComovingVolume" title="ml4gw.distributions.UniformComovingVolume"><code class="xref py py-meth docutils literal notranslate"><span class="pre">UniformComovingVolume()</span></code></a> constructor.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.distributions.Sine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.distributions.</span></span><span class="sig-name descname"><span class="pre">Sine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">low</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.141592653589793</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.Sine" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedDistribution</span></code></p>
<p>Sine distribution based on
<code class="docutils literal notranslate"><span class="pre">torch.distributions.TransformedDistribution</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ml4gw.distributions.UniformComovingVolume">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ml4gw.distributions.</span></span><span class="sig-name descname"><span class="pre">UniformComovingVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">minimum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'redshift'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">67.66</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega_m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.30966</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_grid_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.UniformComovingVolume" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></p>
<p>Sample either redshift, comoving distance, or luminosity distance
such that they are uniform in comoving volume, assuming a flat
lambda-CDM cosmology. Default H0 and Omega_M values match
<a class="reference external" href="https://docs.astropy.org/en/latest/api/astropy.cosmology.realizations.Planck18.html">Planck18 parameters in Astropy</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>minimum</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Minimum distance in the specified distance type</p></li>
<li><p><strong>maximum</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Maximum distance in the specified distance type</p></li>
<li><p><strong>distance_type</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></span>) -- Type of distance to sample from. Can be <code class="docutils literal notranslate"><span class="pre">redshift</span></code>,
<code class="docutils literal notranslate"><span class="pre">comoving_distance</span></code>, or <code class="docutils literal notranslate"><span class="pre">luminosity_distance</span></code></p></li>
<li><p><strong>h0</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Hubble constant in km/s/Mpc</p></li>
<li><p><strong>omega_m</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Matter density parameter</p></li>
<li><p><strong>z_max</strong> -- Maximum redshift for the grid</p></li>
<li><p><strong>grid_size</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) -- Number of points in the grid for interpolation</p></li>
<li><p><strong>validate_args</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>]</span>) -- Whether to validate arguments</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ml4gw.distributions.UniformComovingVolume.arg_constraints">
<span class="sig-name descname"><span class="pre">arg_constraints</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#ml4gw.distributions.UniformComovingVolume.arg_constraints" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ml4gw.distributions.UniformComovingVolume.log_prob">
<span class="sig-name descname"><span class="pre">log_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.UniformComovingVolume.log_prob" title="Link to this definition"></a></dt>
<dd><p>Returns the log of the probability density/mass function evaluated at
<cite>value</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ml4gw.distributions.UniformComovingVolume.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.distributions.UniformComovingVolume.rsample" title="Link to this definition"></a></dt>
<dd><p>Generates a sample_shape shaped reparameterized sample or sample_shape
shaped batch of reparameterized samples if the distribution parameters
are batched.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ml4gw.distributions.UniformComovingVolume.support">
<span class="sig-name descname"><span class="pre">support</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">GreaterThanEq(lower_bound=0.0)</span></em><a class="headerlink" href="#ml4gw.distributions.UniformComovingVolume.support" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-ml4gw.gw">
<span id="ml4gw-gw-module"></span><h2>ml4gw.gw module<a class="headerlink" href="#module-ml4gw.gw" title="Link to this heading"></a></h2>
<p>Tools for manipulating raw gravitational waveforms
and projecting them onto interferometer responses.
Much of the projection code is an extension of the
implementation made available in
<a class="reference external" href="https://arxiv.org/abs/1811.02042">bilby</a>.
Specifically code from
<a class="reference external" href="https://github.com/lscsoft/bilby/blob/master/bilby/gw/detector/interferometer.py">this module</a>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.breathing">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">breathing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.breathing" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">space</span> <span class="pre">space']</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.compute_antenna_responses">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">compute_antenna_responses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_tensors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.compute_antenna_responses" title="Link to this definition"></a></dt>
<dd><p>Compute the antenna pattern factors of a batch of
waveforms as a function of the sky parameters of
their sources as well as the detector tensors of
the interferometers whose response is being
calculated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch']</span></code></span>) -- Angle of each source in radians relative
to the celestial equator</p></li>
<li><p><strong>psi</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch']</span></code></span>) -- Angle in radians between each source's
natural polarization basis and the basis
which has the 0th unit vector pointing along
the celestial equator</p></li>
<li><p><strong>phi</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch']</span></code></span>) -- Angle in radians between each source's right
ascension and the right ascension of the
geocenter</p></li>
<li><p><strong>detector_tensors</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">3</span> <span class="pre">3']</span></code></span>) -- Detector tensor for each of the interferometers
for which a response is being calculated, stacked
along the 0th axis</p></li>
<li><p><strong>modes</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]</span>) -- Which polarization modes to compute the response for</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">polarizations</span> <span class="pre">num_ifos']</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A tensor representing interferometer antenna pattern</dt><dd><p>factors for each of the polarizations of each of
the waveforms, for each interferometer.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.compute_ifo_snr">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">compute_ifo_snr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">responses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.compute_ifo_snr" title="Link to this definition"></a></dt>
<dd><p>Compute the SNRs of a batch of interferometer responses</p>
<p>Compute the signal to noise ratio (SNR) of individual
interferometer responses to gravitational waveforms with
respect to a background PSD for each interferometer. The
SNR of the <span class="math notranslate nohighlight">\(i\)</span> th waveform at the <span class="math notranslate nohighlight">\(j\)</span> th interferometer
is computed as:</p>
<div class="math notranslate nohighlight">
\[\rho_{ij} =
4 \int_{f_{\text{min}}}^{f_{\text{max}}}
\frac{\tilde{h_{ij}}(f)\tilde{h_{ij}}^*(f)}
{S_n^{(j)}(f)}df\]</div>
<p>Where <span class="math notranslate nohighlight">\(f_{\text{min}}\)</span> is a minimum frequency denoted
by <code class="docutils literal notranslate"><span class="pre">highpass</span></code>, <span class="math notranslate nohighlight">\(f_{\text{max}}\)</span> is the maximum frequency
denoted by <code class="docutils literal notranslate"><span class="pre">lowpass</span></code>, which defaults to the Nyquist frequency
dictated by <code class="docutils literal notranslate"><span class="pre">sample_rate</span></code>; <span class="math notranslate nohighlight">\(\tilde{h}_{ij}\)</span> and <span class="math notranslate nohighlight">\(\tilde{h}_{ij}^*\)</span>
indicate the fourier transform of the <span class="math notranslate nohighlight">\(i\)</span> th waveform at
the <span class="math notranslate nohighlight">\(j\)</span> th inteferometer and its complex conjugate, respectively;
and <span class="math notranslate nohighlight">\(S_n^{(j)}\)</span> is the backround PSD at the <span class="math notranslate nohighlight">\(j\)</span> th interferometer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>responses</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">num_ifos</span> <span class="pre">time']</span></code></span>) -- A batch of interferometer responses to a batch of
raw gravitational waveforms</p></li>
<li><p><strong>psd</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">frequency']</span></code></span>) -- The one-sided power spectral density of the background
noise at each interferometer to which a response
in <cite>responses</cite> has been calculated. If 2D, each row of
<cite>psd</cite> will be assumed to be the background PSD for each
channel of _every_ batch element in <cite>responses</cite>. If 3D,
this should contain a background PSD for each channel
of each element in <cite>responses</cite>, and therefore the first
two dimensions of <cite>psd</cite> and <cite>responses</cite> should match.</p></li>
<li><p><strong>sample_rate</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- The frequency at which the waveform responses timeseries
have been sampled. Upon fourier transforming, should
match the frequency resolution of the provided PSDs.</p></li>
<li><p><strong>highpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'frequency']</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) -- The minimum frequency above which to compute the SNR.
If a tensor is provided, it will be assumed to be a
pre-computed mask used to 0-out low frequency components.
If a float, it will be used to compute such a mask. If
left as <cite>None</cite>, all frequencies up to <cite>lowpass</cite>
will contribute to the SNR calculation.</p></li>
<li><p><strong>lowpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'frequency']</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) -- The maximum frequency below which to compute the SNR.
If a tensor is provided, it will be assumed to be a
pre-computed mask used to 0-out high frequency components.
If a float, it will be used to compute such a mask. If
left as <cite>None</cite>, all frequencies from <cite>highpass</cite> up to
the Nyquist freqyency will contribute to the SNR calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">num_ifos']</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Batch of SNRs computed for each interferometer</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.compute_network_snr">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">compute_network_snr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">responses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.compute_network_snr" title="Link to this definition"></a></dt>
<dd><p>Compute the total SNR from a gravitational waveform
from a network of interferometers. The total SNR for
the <span class="math notranslate nohighlight">\(i\)</span> th waveform is computed as</p>
<div class="math notranslate nohighlight">
\[\rho_i = \sqrt{\sum_{j}^{N}\rho_{ij}^2}\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho_{ij}\)</span> is the SNR for the <span class="math notranslate nohighlight">\(i\)</span> th waveform at
the <span class="math notranslate nohighlight">\(j\)</span> th interferometer in the network and <span class="math notranslate nohighlight">\(N\)</span> is
the total number of interferometers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>responses</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">num_ifos</span> <span class="pre">time']</span></code></span>) -- A batch of interferometer responses to a batch of
raw gravitational waveforms</p></li>
<li><p><strong>backgrounds</strong> -- The one-sided power spectral density of the background
noise at each interferometer to which a response
in <code class="docutils literal notranslate"><span class="pre">responses</span></code> has been calculated. If 2D, each row of
<code class="docutils literal notranslate"><span class="pre">psd</span></code> will be assumed to be the background PSD for each
channel of <strong>every</strong> batch element in <code class="docutils literal notranslate"><span class="pre">responses</span></code>. If 3D,
this should contain a background PSD for each channel
of each element in <code class="docutils literal notranslate"><span class="pre">responses</span></code>, and therefore the first
two dimensions of <code class="docutils literal notranslate"><span class="pre">psd</span></code> and <code class="docutils literal notranslate"><span class="pre">responses</span></code> should match.</p></li>
<li><p><strong>sample_rate</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- The frequency at which the waveform responses timeseries
have been sampled. Upon fourier transforming, should
match the frequency resolution of the provided PSDs.</p></li>
<li><p><strong>highpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'frequency']</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) -- The minimum frequency above which to compute the SNR.
If a tensor is provided, it will be assumed to be a
pre-computed mask used to 0-out low frequency components.
If a float, it will be used to compute such a mask. If
left as <code class="docutils literal notranslate"><span class="pre">None</span></code>, all frequencies up to <code class="docutils literal notranslate"><span class="pre">sample_rate</span> <span class="pre">/</span> <span class="pre">2</span></code>
will contribute to the SNR calculation.</p></li>
<li><p><strong>lowpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'frequency']</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) -- The maximum frequency below which to compute the SNR.
If a tensor is provided, it will be assumed to be a
pre-computed mask used to 0-out high frequency components.
If a float, it will be used to compute such a mask. If
left as <code class="docutils literal notranslate"><span class="pre">None</span></code>, all frequencies from <code class="docutils literal notranslate"><span class="pre">highpass</span></code> up to
the Nyquist freqyency will contribute to the SNR calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch']</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Batch of SNRs for each waveform across the interferometer network</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.compute_observed_strain">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">compute_observed_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_tensors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">polarizations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.compute_observed_strain" title="Link to this definition"></a></dt>
<dd><p>Compute the strain timeseries $h(t)$ observed by a network
of interferometers from the given polarization timeseries
corresponding to gravitational waveforms from sources with
the indicated sky parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dec</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch']</span></code></span>) -- Declination of each source in radians relative
to the celestial north</p></li>
<li><p><strong>psi</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch']</span></code></span>) -- Angle in radians between each source's
natural polarization basis and the basis
which has the 0th unit vector pointing along
the celestial equator</p></li>
<li><p><strong>phi</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch']</span></code></span>) -- Angle in radians between each source's right
ascension and the right ascension of the
geocenter</p></li>
<li><p><strong>detector_tensors</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">3</span> <span class="pre">3']</span></code></span>) -- Detector tensor for each of the interferometers
for which observed strain is being calculated,
stacked along the 0th axis</p></li>
<li><p><strong>detector_vertices</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">3']</span></code></span>) -- Vertices for each interferometer's spatial location
relative to the geocenter. Used to compute delay
between the waveform observed at the geocenter and
the one observed at the detector site. To avoid
adding any delay between the two, reset your coordinates
such that the desired interferometer is at <cite>(0., 0., 0.)</cite>.</p></li>
<li><p><strong>sample_rate</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Rate at which the polarization timeseries have been sampled</p></li>
<li><p><strong>polarziations</strong> -- Timeseries for each waveform polarization which
contributes to the interferometer response. Allowed
polarizations are <cite>cross</cite>, <cite>plus</cite>, and <cite>breathing</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">num_ifos</span> <span class="pre">time']</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tensor representing the observed strain at each
interferometer for each waveform.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.cross">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">cross</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.cross" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">space</span> <span class="pre">space']</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.get_ifo_geometry">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">get_ifo_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">ifos</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.get_ifo_geometry" title="Link to this definition"></a></dt>
<dd><p>For a given list of interferometer names, retrieve and
concatenate the associated detector tensors and vertices
of those interferometers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ifos</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></span>) -- Names of the interferometers whose geometry to retrieve</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">3</span> <span class="pre">3']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">3']</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A concatenation of the detector tensors of each interferometer
A concatenation of the vertices of each interferometer</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.outer">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">outer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.outer" title="Link to this definition"></a></dt>
<dd><p>Compute the outer product of two batches of vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">space</span> <span class="pre">space']</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.plus">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.plus" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">space</span> <span class="pre">space']</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.reweight_snrs">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">reweight_snrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">responses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_snrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.reweight_snrs" title="Link to this definition"></a></dt>
<dd><p>Scale interferometer responses such that they have a desired SNR</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>responses</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">num_ifos</span> <span class="pre">time']</span></code></span>) -- A batch of interferometer responses to a batch of
raw gravitational waveforms</p></li>
<li><p><strong>target_snrs</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch']</span></code>]</span>) -- Either a tensor of desired SNRs for each waveform,
or a single SNR to which all waveforms should be scaled.</p></li>
<li><p><strong>psd</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">frequency']</span></code></span>) -- The one-sided power spectral density of the background
noise at each interferometer to which a response
in <code class="docutils literal notranslate"><span class="pre">responses</span></code> has been calculated. If 2D, each row of
<code class="docutils literal notranslate"><span class="pre">psd</span></code> will be assumed to be the background PSD for each
channel of <strong>every</strong> batch element in <code class="docutils literal notranslate"><span class="pre">responses</span></code>. If 3D,
this should contain a background PSD for each channel
of each element in <code class="docutils literal notranslate"><span class="pre">responses</span></code>, and therefore the first
two dimensions of <code class="docutils literal notranslate"><span class="pre">psd</span></code> and <code class="docutils literal notranslate"><span class="pre">responses</span></code> should match.</p></li>
<li><p><strong>sample_rate</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- The frequency at which the waveform responses timeseries
have been sampled. Upon fourier transforming, should
match the frequency resolution of the provided PSDs.</p></li>
<li><p><strong>highpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'frequency']</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) -- The minimum frequency above which to compute the SNR.
If a tensor is provided, it will be assumed to be a
pre-computed mask used to 0-out low frequency components.
If a float, it will be used to compute such a mask. If
left as <code class="docutils literal notranslate"><span class="pre">None</span></code>, all frequencies up to <code class="docutils literal notranslate"><span class="pre">sample_rate</span> <span class="pre">/</span> <span class="pre">2</span></code>
will contribute to the SNR calculation.</p></li>
<li><p><strong>lowpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'frequency']</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) -- The maximum frequency below which to compute the SNR.
If a tensor is provided, it will be assumed to be a
pre-computed mask used to 0-out high frequency components.
If a float, it will be used to compute such a mask. If
left as <code class="docutils literal notranslate"><span class="pre">None</span></code>, all frequencies from <code class="docutils literal notranslate"><span class="pre">highpass</span></code> up to
the Nyquist freqyency will contribute to the SNR calculation.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">num_ifos</span> <span class="pre">time']</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Rescaled interferometer responses</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.gw.shift_responses">
<span class="sig-prename descclassname"><span class="pre">ml4gw.gw.</span></span><span class="sig-name descname"><span class="pre">shift_responses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">responses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.gw.shift_responses" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">num_ifos</span> <span class="pre">time']</span></code></span></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-ml4gw.spectral">
<span id="ml4gw-spectral-module"></span><h2>ml4gw.spectral module<a class="headerlink" href="#module-ml4gw.spectral" title="Link to this heading"></a></h2>
<p>Several implementation details are derived from the scipy csd and welch
implementations. For more info, see</p>
<p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.welch.html</a></p>
<p>and</p>
<p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.csd.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.csd.html</a></p>
<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.spectral.fast_spectral_density">
<span class="sig-prename descclassname"><span class="pre">ml4gw.spectral.</span></span><span class="sig-name descname"><span class="pre">fast_spectral_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperseg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstride</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.spectral.fast_spectral_density" title="Link to this definition"></a></dt>
<dd><p>Compute the power spectral density of a multichannel
timeseries or a batch of multichannel timeseries, or
the cross power spectral density of two such timeseries.
This implementation is non-exact for the two lowest
frequency bins, since it implements centering using the
mean for the entire timeseries rather than on a per-
window basis. The benefit of this is a faster implementation,
which might be beneficial for cases where the lowest
frequency components are going to be discarded anyway.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'time']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'channel</span> <span class="pre">time']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">channel</span> <span class="pre">time']</span></code>]</span>) -- The timeseries tensor whose power spectral density
to compute, or for cross spectral density the
timeseries whose fft will be conjugated. Can have
shape <code class="docutils literal notranslate"><span class="pre">(batch_size,</span> <span class="pre">num_channels,</span> <span class="pre">length</span> <span class="pre">*</span> <span class="pre">sample_rate)</span></code>,
<code class="docutils literal notranslate"><span class="pre">(num_channels,</span> <span class="pre">length</span> <span class="pre">*</span> <span class="pre">sample_rate)</span></code>, or
<code class="docutils literal notranslate"><span class="pre">(length</span> <span class="pre">*</span> <span class="pre">sample_rate)</span></code>.</p></li>
<li><p><strong>nperseg</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) -- Number of samples included in each FFT window</p></li>
<li><p><strong>nstride</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) -- Stride between FFT windows</p></li>
<li><p><strong>window</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'{nperseg//2+1}']</span></code></span>) -- Window array to multiply by each FFT window before
FFT computation. Should have length <code class="docutils literal notranslate"><span class="pre">nperseg</span> <span class="pre">//</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p></li>
<li><p><strong>scale</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Scale factor to multiply the FFT'd data by, related to
desired units for output tensor (e.g. letting this equal
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(sample_rate</span> <span class="pre">*</span> <span class="pre">(window**2).sum())</span></code> will give output
units of density, :math`text{Hz}^-1`.</p></li>
<li><p><strong>average</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></span>) -- How to aggregate the contributions of each FFT window to
the spectral density. Allowed options are <code class="docutils literal notranslate"><span class="pre">'mean'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'median'</span></code>.</p></li>
<li><p><strong>y</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'time']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'channel</span> <span class="pre">time']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">channel</span> <span class="pre">time']</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>]</span>) -- Timeseries tensor to compute cross spectral density
with <code class="docutils literal notranslate"><span class="pre">x</span></code>. If left as <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>'s power spectral
density will be returned. Otherwise, if <code class="docutils literal notranslate"><span class="pre">x</span></code> is 1D,
<code class="docutils literal notranslate"><span class="pre">y</span></code> must also be 1D. If <code class="docutils literal notranslate"><span class="pre">x</span></code> is 2D, the assumption
is that this represents a single multi-channel timeseries,
and <code class="docutils literal notranslate"><span class="pre">y</span></code> must be either 2D or 1D. In the former case,
the cross-spectral densities of each channel will be
computed individually, so <code class="docutils literal notranslate"><span class="pre">y</span></code> must have the same shape as <code class="docutils literal notranslate"><span class="pre">x</span></code>.
Otherwise, this will compute the CSD of each of <code class="docutils literal notranslate"><span class="pre">x</span></code>'s channels
with <code class="docutils literal notranslate"><span class="pre">y</span></code>. If <code class="docutils literal notranslate"><span class="pre">x</span></code> is 3D, this will be assumed to be a batch
of multi-channel timeseries. In this case, <code class="docutils literal notranslate"><span class="pre">y</span></code> can either
be 3D, in which case each channel of each batch element will
have its CSD calculated or 2D, which has two different options.
If <code class="docutils literal notranslate"><span class="pre">y</span></code>'s 0th dimension matches <code class="docutils literal notranslate"><span class="pre">x</span></code>'s 0th dimension, it will
be assumed that <code class="docutils literal notranslate"><span class="pre">y</span></code> represents a batch of 1D timeseries, and
for each batch element this timeseries will have its CSD with
each channel of the corresponding batch element of <code class="docutils literal notranslate"><span class="pre">x</span></code>
calculated. Otherwise, it sill be assumed that <code class="docutils literal notranslate"><span class="pre">y</span></code> represents
a single multi-channel timeseries, in which case each channel
of <code class="docutils literal notranslate"><span class="pre">y</span></code> will have its CSD calculated with the corresponding
channel in <code class="docutils literal notranslate"><span class="pre">x</span></code> across _all_ of <code class="docutils literal notranslate"><span class="pre">x</span></code>'s batch elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'frequency']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'channel</span> <span class="pre">frequency']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">channel</span> <span class="pre">frequency']</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tensor of power spectral densities of <code class="docutils literal notranslate"><span class="pre">x</span></code> or its cross spectral
density with the timeseries in <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.spectral.median">
<span class="sig-prename descclassname"><span class="pre">ml4gw.spectral.</span></span><span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.spectral.median" title="Link to this definition"></a></dt>
<dd><p>Implements a median calculation that matches numpy's
behavior for an even number of elements and includes
the same bias correction used by
<a class="reference external" href="https://github.com/scipy/scipy/blob/main/scipy/signal/_spectral_py.py#L2066">scipy's implementation</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">']</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.spectral.normalize_by_psd">
<span class="sig-prename descclassname"><span class="pre">ml4gw.spectral.</span></span><span class="sig-name descname"><span class="pre">normalize_by_psd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.spectral.normalize_by_psd" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.spectral.spectral_density">
<span class="sig-prename descclassname"><span class="pre">ml4gw.spectral.</span></span><span class="sig-name descname"><span class="pre">spectral_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nperseg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstride</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'median'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.spectral.spectral_density" title="Link to this definition"></a></dt>
<dd><p>Compute the power spectral density of a multichannel
timeseries or a batch of multichannel timeseries.
This implementation is exact for all frequency bins, but
slower than the fast implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'time']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'channel</span> <span class="pre">time']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">channel</span> <span class="pre">time']</span></code>]</span>) -- The timeseries tensor whose power spectral density
to compute, or for cross spectral density the
timeseries whose fft will be conjugated. Can have
shape <code class="docutils literal notranslate"><span class="pre">(batch_size,</span> <span class="pre">num_channels,</span> <span class="pre">length</span> <span class="pre">*</span> <span class="pre">sample_rate)</span></code>,
<code class="docutils literal notranslate"><span class="pre">(num_channels,</span> <span class="pre">length</span> <span class="pre">*</span> <span class="pre">sample_rate)</span></code>, or
<code class="docutils literal notranslate"><span class="pre">(length</span> <span class="pre">*</span> <span class="pre">sample_rate)</span></code>.</p></li>
<li><p><strong>nperseg</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) -- Number of samples included in each FFT window</p></li>
<li><p><strong>nstride</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) -- Stride between FFT windows</p></li>
<li><p><strong>window</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'{nperseg//2+1}']</span></code></span>) -- Window array to multiply by each FFT window before
FFT computation. Should have length <code class="docutils literal notranslate"><span class="pre">nperseg</span> <span class="pre">//</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p></li>
<li><p><strong>scale</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Scale factor to multiply the FFT'd data by, related to
desired units for output tensor (e.g. letting this equal
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(sample_rate</span> <span class="pre">*</span> <span class="pre">(window**2).sum())</span></code> will give output
units of density, <span class="math notranslate nohighlight">\(\text{Hz}^-1\)</span>.</p></li>
<li><p><strong>average</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></span>) -- How to aggregate the contributions of each FFT window to
the spectral density. Allowed options are <code class="docutils literal notranslate"><span class="pre">'mean'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'median'</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'frequency']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'channel</span> <span class="pre">frequency']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">channel</span> <span class="pre">frequency']</span></code>]</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.spectral.truncate_inverse_power_spectrum">
<span class="sig-prename descclassname"><span class="pre">ml4gw.spectral.</span></span><span class="sig-name descname"><span class="pre">truncate_inverse_power_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fduration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.spectral.truncate_inverse_power_spectrum" title="Link to this definition"></a></dt>
<dd><p>Truncate the length of the time domain response
of a whitening filter built using the specified
<code class="docutils literal notranslate"><span class="pre">psd</span></code> so that it has maximum length <code class="docutils literal notranslate"><span class="pre">fduration</span></code>
seconds. This is meant to mitigate the impact
of sharp features in the background PSD causing
time domain responses longer than the segments
to which the whitening filter will be applied.</p>
<p>Implementation details adapted from
<a class="reference external" href="https://github.com/vivinousi/gw-detection-deep-learning/blob/203966cc2ee47c32c292be000fb009a16824b7d9/modules/whiten.py#L8">here</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psd</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">frequency']</span></code></span>) -- The one-sided power spectraul density used
to construct a whitening filter.</p></li>
<li><p><strong>fduration</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'time']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) -- Desired length in seconds of the time domain
response of a whitening filter built using
this PSD, or a window of this length to taper
the edges of the time domain response of the
filter. If passed as a float, a Hann window
of this length will be used.</p></li>
<li><p><strong>sample_rate</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Rate at which the time domain data to which
the whitening filter will be applied has been
sampled.</p></li>
<li><p><strong>highpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) -- If specified, will zero out the frequency response
of all frequencies below this value in Hz. If left
as <cite>None</cite>, no highpass filtering will be applied.</p></li>
<li><p><strong>lowpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) -- If specified, will zero out the frequency response
of all frequencies above this value in Hz. If left
as <cite>None</cite>, no lowpass filtering will be applied.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">frequency']</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>The PSD with its time domain response truncated</dt><dd><p>to <code class="docutils literal notranslate"><span class="pre">fduration</span></code> and any filtered frequencies
tapered.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ml4gw.spectral.whiten">
<span class="sig-prename descclassname"><span class="pre">ml4gw.spectral.</span></span><span class="sig-name descname"><span class="pre">whiten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fduration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">highpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowpass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ml4gw.spectral.whiten" title="Link to this definition"></a></dt>
<dd><p>Whiten a batch of timeseries using the specified
background one-sided power spectral densities (PSDs),
modified to have the desired time domain response length
<code class="docutils literal notranslate"><span class="pre">fduration</span></code> and possibly to highpass/lowpass filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">num_ifos</span> <span class="pre">time']</span></code></span>) -- batch of multichannel timeseries to whiten</p></li>
<li><p><strong>psd</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'num_ifos</span> <span class="pre">frequency']</span></code></span>) -- PSDs use to whiten the data. The frequency
response of the whitening filter will be roughly
the inverse of the square root of this PSD, ensuring
that data from the same distribution will have
approximately uniform power after whitening.
If 2D, each batch element in <code class="docutils literal notranslate"><span class="pre">X</span></code> will be whitened
using the same PSDs. If 3D, each batch element will
be whitened by the PSDs contained along the 0th
dimenion of <code class="docutils literal notranslate"><span class="pre">psd</span></code>, and so the first two dimensions
of <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">psd</span></code> should match.</p></li>
<li><p><strong>fduration</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'time']</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) -- Desired length in seconds of the time domain
response of a whitening filter built using
this PSD, or a window of this length to taper
the edges of the time domain response of the
filter. If passed as a float, a Hann window
of this length will be used. Moreover, half of
this length will be removed from each edge of
the whitened timeseries to account for filter
settle-in time.</p></li>
<li><p><strong>sample_rate</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></span>) -- Rate at which the data in <code class="docutils literal notranslate"><span class="pre">X</span></code> has been sampled</p></li>
<li><p><strong>highpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) -- The frequency in Hz at which to highpass filter
the data, setting the frequency response in the
whitening filter to 0. If left as <cite>None</cite>, no
highpass filtering will be applied.</p></li>
<li><p><strong>lowpass</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) -- The frequency in Hz at which to lowpass filter
the data, setting the frequency response in the
whitening filter to 0. If left as <code class="docutils literal notranslate"><span class="pre">None</span></code>, no
lowpass filtering will be applied.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float[Tensor,</span> <span class="pre">'batch</span> <span class="pre">num_ifos</span> <span class="pre">time']</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>Batch of whitened multichannel timeseries with</dt><dd><p><code class="docutils literal notranslate"><span class="pre">fduration</span> <span class="pre">/</span> <span class="pre">2</span></code> seconds trimmed from each side.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-ml4gw.types">
<span id="ml4gw-types-module"></span><h2>ml4gw.types module<a class="headerlink" href="#module-ml4gw.types" title="Link to this heading"></a></h2>
</section>
<section id="module-ml4gw">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-ml4gw" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="modules.html" class="btn btn-neutral float-left" title="ml4gw" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ml4gw.dataloading.html" class="btn btn-neutral float-right" title="ml4gw.dataloading package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Alec Gunny, Ethan Marx, William Benoit, Deep Chatterjee.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>