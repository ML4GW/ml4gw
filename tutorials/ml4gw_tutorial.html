<!DOCTYPE html>
<html class="writer-html5" lang="python" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ml4gw Tutorial &mdash; ml4gw  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=d048f138"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tutorial on distribution approximation and posterior estimation" href="ml4gw_lfi_tutorial.html" />
    <link rel="prev" title="Whitening" href="../examples/transforms.whitening.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            ml4gw
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Example Usage</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">ml4gw</span></code> Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#waveform-generation">Waveform Generation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#parameter-sampling">Parameter sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generation-in-the-frequency-domain">Generation in the frequency domain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#time-domain-waveforms">Time-domain waveforms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#waveform-projection">Waveform projection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#psd-estimation">PSD Estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#snr-calculation">SNR Calculation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dataloading">Dataloading</a></li>
<li class="toctree-l2"><a class="reference internal" href="#whitening">Whitening</a></li>
<li class="toctree-l2"><a class="reference internal" href="#transforms">Transforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#architectures">Architectures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-training-setup">Example training setup</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ml4gw_lfi_tutorial.html">Tutorial on distribution approximation and posterior estimation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/ml4gw.html">ml4gw</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/ml4gw.utils.html">ml4gw.utils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ml4gw</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><code class="docutils literal notranslate"><span class="pre">ml4gw</span></code> Tutorial</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/tutorials/ml4gw_tutorial.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="ml4gw-tutorial">
<h1><a class="reference external" href="https://github.com/ML4GW/ml4gw"><code class="docutils literal notranslate"><span class="pre">ml4gw</span></code></a> Tutorial<a class="headerlink" href="#ml4gw-tutorial" title="Link to this heading"></a></h1>
<p>This tutorial has two parts:</p>
<ol class="arabic simple">
<li><p>An overview of many of the features of <code class="docutils literal notranslate"><span class="pre">ml4gw</span></code>, with demonstrations</p></li>
<li><p>An example of training a model using these features</p></li>
</ol>
<p><strong>Requirements:</strong> This notebook requires a number of packages besides <code class="docutils literal notranslate"><span class="pre">ml4gw</span></code> to run completely.
Install with:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span><span class="s2">&quot;ml4gw&gt;=0.7.6&quot;</span><span class="w"> </span><span class="s2">&quot;gwpy&gt;=3.0&quot;</span><span class="w"> </span><span class="s2">&quot;h5py&gt;=3.12&quot;</span><span class="w"> </span><span class="s2">&quot;torchmetrics&gt;=1.6&quot;</span><span class="w"> </span><span class="s2">&quot;lightning&gt;=2.4.0&quot;</span><span class="w"> </span><span class="s2">&quot;rich&gt;=10.2.2,&lt;14.0&quot;</span>
</pre></div>
</div>
<p>To install these packages into your current environment, uncomment and run the code block below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># !pip install &quot;ml4gw&gt;=0.7.6&quot; &quot;gwpy&gt;=3.0&quot; &quot;h5py&gt;=3.12&quot; &quot;torchmetrics&gt;=1.6&quot; &quot;lightning&gt;=2.4.0&quot; &quot;rich&gt;=10.2.2,&lt;14.0&quot;</span>
</pre></div>
</div>
</div>
</div>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>We’ll go through this as though our goal is to build a binary black hole detection model,
with some excursions to look at other features. Much of this is similar to how the <a class="reference external" href="https://www.github.com/ML4GW/aframe">Aframe</a> algorithm works.
The development of <code class="docutils literal notranslate"><span class="pre">ml4gw</span></code> was guided by what was needed for Aframe,
which makes BBH detection a good test case.</p>
<p>Goals of this tutorial:</p>
<ul class="simple">
<li><p>Introduce and demonstrate how to interact with many of the features of <code class="docutils literal notranslate"><span class="pre">ml4gw</span></code></p></li>
<li><p>Explain why these tools are useful for doing machine learning in gravitational wave physics</p></li>
<li><p>Present areas where it may be possible to contribute to <code class="docutils literal notranslate"><span class="pre">ml4gw</span></code></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s2">&quot;text.usetex&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s2">&quot;font.family&quot;</span><span class="p">:</span> <span class="s2">&quot;Computer Modern&quot;</span><span class="p">,</span>
        <span class="s2">&quot;font.size&quot;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
        <span class="s2">&quot;figure.dpi&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="c1"># Most of this notebook can be run on CPU in a reasonable amount of time.</span>
<span class="c1"># The example training at the end cannot be.</span>
<span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="waveform-generation">
<h2>Waveform Generation<a class="headerlink" href="#waveform-generation" title="Link to this heading"></a></h2>
<p>We’ll start by generating some BBH waveforms. Currently, <code class="docutils literal notranslate"><span class="pre">ml4gw</span></code> has implemented the following <a class="reference external" href="https://github.com/ML4GW/ml4gw/tree/main/ml4gw/waveforms/cbc">CBC waveforms</a>: TaylorF2, IMRPhenomD, and IMRPhenomPv2. We’ll use IMRPhenomD for our example. These are all frequency-domain waveforms, and so return a frequency-series of gravitational-wave strain. We provide the <a class="reference external" href="https://github.com/ML4GW/ml4gw/blob/main/ml4gw/waveforms/generator.py"><code class="docutils literal notranslate"><span class="pre">TimeDomainCBCWaveformGenerator</span></code></a> class for producing time-domain signals; however, we’ll start with frequency-domain.</p>
<p>Additionally, sine-gaussian and ringdown (damped cosinusoidal) waveforms are <a class="reference external" href="https://github.com/ML4GW/ml4gw/tree/main/ml4gw/waveforms/adhoc">available</a>.</p>
<p>These modules allow simultaneous generation of batches of waveforms from a set of parameters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Desired duration of time-domain waveform</span>
<span class="n">waveform_duration</span> <span class="o">=</span> <span class="mi">8</span>
<span class="c1"># Sample rate of all the data we&#39;ll be using today</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="mi">2048</span>

<span class="c1"># Define minimum, maximum, and reference frequencies</span>
<span class="n">f_min</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">f_max</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">f_ref</span> <span class="o">=</span> <span class="mi">20</span>

<span class="n">nyquist</span> <span class="o">=</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">num_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">waveform_duration</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
<span class="n">num_freqs</span> <span class="o">=</span> <span class="n">num_samples</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># Create an array of frequency values at which to generate our waveform</span>
<span class="c1"># At the moment, only frequency-domain approximants have been implemented</span>
<span class="n">frequencies</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nyquist</span><span class="p">,</span> <span class="n">num_freqs</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="n">freq_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">frequencies</span> <span class="o">&gt;=</span> <span class="n">f_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">frequencies</span> <span class="o">&lt;</span> <span class="n">f_max</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="parameter-sampling">
<h3>Parameter sampling<a class="headerlink" href="#parameter-sampling" title="Link to this heading"></a></h3>
<p>To generate waveforms, we need sets of parameters. For creating a training dataset, we’d like to randomly sample these parameters from some probability distributions.</p>
<p>PyTorch has its own <a class="reference external" href="https://pytorch.org/docs/stable/distributions.html">probability distributions</a>, but there are some distributions that they haven’t yet implemented (at least at time of writing), so we implemented them <a class="reference external" href="https://github.com/ML4GW/ml4gw/blob/main/ml4gw/distributions.py">ourselves</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.distributions</span><span class="w"> </span><span class="kn">import</span> <span class="n">PowerLaw</span><span class="p">,</span> <span class="n">Sine</span><span class="p">,</span> <span class="n">Cosine</span><span class="p">,</span> <span class="n">DeltaFunction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.distributions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Uniform</span>

<span class="c1"># On CPU, keep the number of waveforms around 100. On GPU, you can go higher,</span>
<span class="c1"># subject to memory constraints.</span>
<span class="n">num_waveforms</span> <span class="o">=</span> <span class="mi">500</span>

<span class="c1"># Create a dictionary of parameter distributions</span>
<span class="c1"># This is not intended to be an astrophysically</span>
<span class="c1"># meaningful distribution</span>
<span class="n">param_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;chirp_mass&quot;</span><span class="p">:</span> <span class="n">PowerLaw</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.35</span><span class="p">),</span>
    <span class="s2">&quot;mass_ratio&quot;</span><span class="p">:</span> <span class="n">Uniform</span><span class="p">(</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">),</span>
    <span class="s2">&quot;chi1&quot;</span><span class="p">:</span> <span class="n">Uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.999</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">),</span>
    <span class="s2">&quot;chi2&quot;</span><span class="p">:</span> <span class="n">Uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.999</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">),</span>
    <span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="n">PowerLaw</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="s2">&quot;phic&quot;</span><span class="p">:</span> <span class="n">DeltaFunction</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;inclination&quot;</span><span class="p">:</span> <span class="n">Sine</span><span class="p">(),</span>
<span class="p">}</span>

<span class="c1"># And then sample from each of those distributions</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">num_waveforms</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="generation-in-the-frequency-domain">
<h3>Generation in the frequency domain<a class="headerlink" href="#generation-in-the-frequency-domain" title="Link to this heading"></a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.waveforms</span><span class="w"> </span><span class="kn">import</span> <span class="n">IMRPhenomD</span>

<span class="n">approximant</span> <span class="o">=</span> <span class="n">IMRPhenomD</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="c1"># Calling the approximant with the frequency array, reference frequency, and waveform parameters</span>
<span class="c1"># returns the cross and plus polarizations</span>
<span class="n">hc_f</span><span class="p">,</span> <span class="n">hp_f</span> <span class="o">=</span> <span class="n">approximant</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">frequencies</span><span class="p">[</span><span class="n">freq_mask</span><span class="p">],</span> <span class="n">f_ref</span><span class="o">=</span><span class="n">f_ref</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hc_f</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">hp_f</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.Size([500, 8032]) torch.Size([500, 8032])
</pre></div>
</div>
</div>
</div>
<p>We now have the plus and cross polarizations 500 BBH waveforms in the frequency domain. We can plot one of them, just to take a look:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note that I have to move data to CPU to plot</span>
<span class="c1"># In an actual training setup, you wouldn&#39;t be moving data between devices so much</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frequencies</span><span class="p">[</span><span class="n">freq_mask</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hp_f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Strain&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/f99b47d6179c28a1bd0678b7ca25c8498aeb9d4b8f3b861391a24ae41a639743.png" src="../_images/f99b47d6179c28a1bd0678b7ca25c8498aeb9d4b8f3b861391a24ae41a639743.png" />
</div>
</div>
</section>
<section id="time-domain-waveforms">
<h3>Time-domain waveforms<a class="headerlink" href="#time-domain-waveforms" title="Link to this heading"></a></h3>
<p>We’ll now generate waveforms in the time domain using the <code class="docutils literal notranslate"><span class="pre">TimeDomainCBCWaveformGenerator</span></code>. This <code class="docutils literal notranslate"><span class="pre">Module</span></code> uses the <code class="docutils literal notranslate"><span class="pre">approximant</span></code> to generate a waveform <code class="docutils literal notranslate"><span class="pre">duration</span></code> seconds long with the given <code class="docutils literal notranslate"><span class="pre">sample_rate</span></code>. The coalescence point of the signal is placed <code class="docutils literal notranslate"><span class="pre">right_pad</span></code> seconds from the right edge of the window. For conditioning the frequency-domain waveforms, the parameter dictionary is required to contain the <code class="docutils literal notranslate"><span class="pre">mass_1</span></code>, <code class="docutils literal notranslate"><span class="pre">mass_2</span></code>, <code class="docutils literal notranslate"><span class="pre">s1z</span></code>, and <code class="docutils literal notranslate"><span class="pre">s2z</span></code> keys. We’ll use a conversion function from <a class="reference external" href="https://github.com/ML4GW/ml4gw/blob/main/ml4gw/waveforms/conversion.py"><code class="docutils literal notranslate"><span class="pre">ml4gw.waveforms.conversion</span></code></a> to add these keys.</p>
<p>Because we’re using IMRPhenomD and have aligned spins <code class="docutils literal notranslate"><span class="pre">s1z</span> <span class="pre">=</span> <span class="pre">chi1</span></code> and <code class="docutils literal notranslate"><span class="pre">s2z</span> <span class="pre">=</span> <span class="pre">chi2</span></code>. If we had non-aligned spins, we could use the <code class="docutils literal notranslate"><span class="pre">bilby_spins_to_lalsim</span></code> conversion function to compute the cartesian spin components.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.waveforms.generator</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeDomainCBCWaveformGenerator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.waveforms.conversion</span><span class="w"> </span><span class="kn">import</span> <span class="n">chirp_mass_and_mass_ratio_to_components</span>

<span class="n">waveform_generator</span> <span class="o">=</span> <span class="n">TimeDomainCBCWaveformGenerator</span><span class="p">(</span>
    <span class="n">approximant</span><span class="o">=</span><span class="n">approximant</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">f_min</span><span class="o">=</span><span class="n">f_min</span><span class="p">,</span>
    <span class="n">duration</span><span class="o">=</span><span class="n">waveform_duration</span><span class="p">,</span>
    <span class="n">right_pad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">f_ref</span><span class="o">=</span><span class="n">f_ref</span><span class="p">,</span>
<span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="n">params</span><span class="p">[</span><span class="s2">&quot;mass_1&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;mass_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chirp_mass_and_mass_ratio_to_components</span><span class="p">(</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;chirp_mass&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;mass_ratio&quot;</span><span class="p">]</span>
<span class="p">)</span>

<span class="n">params</span><span class="p">[</span><span class="s2">&quot;s1z&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;s2z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;chi1&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;chi2&quot;</span><span class="p">]</span>

<span class="n">hc</span><span class="p">,</span> <span class="n">hp</span> <span class="o">=</span> <span class="n">waveform_generator</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">hp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.Size([500, 16384]) torch.Size([500, 16384])
</pre></div>
</div>
</div>
</div>
<p>We now have 500 BBH waveforms, 8 seconds long and sampled at 2048 Hz. We can plot one of these as well:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">waveform_duration</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">hp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Strain&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/6cbdcfc355023dc893e6a0c885e15012ff1ce49fc82561f562709044fbe512ba.png" src="../_images/6cbdcfc355023dc893e6a0c885e15012ff1ce49fc82561f562709044fbe512ba.png" />
</div>
</div>
</section>
<section id="waveform-projection">
<h3>Waveform projection<a class="headerlink" href="#waveform-projection" title="Link to this heading"></a></h3>
<p>We can now project these waveforms and get the observed strain. At present, the projection is the most basic, assuming a fixed orientation between the detector and the source over the duration of the signal. The source code for these functions can be found <a class="reference external" href="https://github.com/ML4GW/ml4gw/blob/main/ml4gw/gw.py">here</a>.</p>
<p>Future feature:</p>
<ul class="simple">
<li><p>Account for the Earth’s rotation and orbit</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.gw</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_ifo_geometry</span><span class="p">,</span> <span class="n">compute_observed_strain</span>

<span class="c1"># Define probability distributions for sky location and polarization angle</span>
<span class="n">dec</span> <span class="o">=</span> <span class="n">Cosine</span><span class="p">()</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<span class="c1"># The interferometer geometry for V1 and K1 are also in ml4gw</span>
<span class="n">ifos</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;H1&quot;</span><span class="p">,</span> <span class="s2">&quot;L1&quot;</span><span class="p">]</span>
<span class="n">tensors</span><span class="p">,</span> <span class="n">vertices</span> <span class="o">=</span> <span class="n">get_ifo_geometry</span><span class="p">(</span><span class="o">*</span><span class="n">ifos</span><span class="p">)</span>

<span class="c1"># Pass the detector geometry, along with the polarizations and sky parameters,</span>
<span class="c1"># to get the observed strain</span>
<span class="n">waveforms</span> <span class="o">=</span> <span class="n">compute_observed_strain</span><span class="p">(</span>
    <span class="n">dec</span><span class="o">=</span><span class="n">dec</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">num_waveforms</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
    <span class="n">psi</span><span class="o">=</span><span class="n">psi</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">num_waveforms</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
    <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">num_waveforms</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
    <span class="n">detector_tensors</span><span class="o">=</span><span class="n">tensors</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
    <span class="n">detector_vertices</span><span class="o">=</span><span class="n">vertices</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
    <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">cross</span><span class="o">=</span><span class="n">hc</span><span class="p">,</span>
    <span class="n">plus</span><span class="o">=</span><span class="n">hp</span><span class="p">,</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.Size([500, 2, 16384])
</pre></div>
</div>
</div>
</div>
<p>We now have a batch of multi-channel time-series data. The first dimension is the batch dimension, and corresponds to the number of waveforms that were generated. The second dimension is the channel dimension, and corresponds to the interferometers that we chose to use in the order they were specified. The third dimension is the time dimension.</p>
<p>We can plot this as well, though there won’t be much difference from before.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;H1&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;L1&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Strain&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/eea6cf21748edeb3c8f5a045b035793556c41f134f51f89b67651b7a8bd46d5c.png" src="../_images/eea6cf21748edeb3c8f5a045b035793556c41f134f51f89b67651b7a8bd46d5c.png" />
</div>
</div>
</section>
<section id="psd-estimation">
<h3>PSD Estimation<a class="headerlink" href="#psd-estimation" title="Link to this heading"></a></h3>
<p>Now that we have our waveforms generated, one thing we might want to do is calculate their SNRs with respect to some background data. To do that, we’ll need the power spectral density of the background. The <a class="reference external" href="https://github.com/ML4GW/ml4gw/blob/main/ml4gw/transforms/spectral.py"><code class="docutils literal notranslate"><span class="pre">SpectralDensity</span></code></a> module can take a batch of multi-channel timeseries data and compute the PSD along the time dimension. We’ll begin by downloading some background data from the Gravitational Wave Open Science Center (GWOSC). This data comes from the Hanford and Livingston and was taken during O3.</p>
<p>One important piece to note is that, due to the scale of the strain, the background data is cast to <code class="docutils literal notranslate"><span class="pre">double</span></code> precision before being given to the module to avoid certain values being zeroed out.</p>
<p>Future feature:</p>
<ul class="simple">
<li><p>Automatically cast input data to <code class="docutils literal notranslate"><span class="pre">double</span></code> unless the user specifies otherwise</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">gwpy.timeseries</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeSeries</span><span class="p">,</span> <span class="n">TimeSeriesDict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># Point this to whatever directory you want to house</span>
<span class="c1"># all of the data products this notebook creates</span>
<span class="n">data_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./data&quot;</span><span class="p">)</span>

<span class="c1"># And this to the directory where you want to download the data</span>
<span class="n">background_dir</span> <span class="o">=</span> <span class="n">data_dir</span> <span class="o">/</span> <span class="s2">&quot;background_data&quot;</span>
<span class="n">background_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># These are the GPS time of the start and end of the segments.</span>
<span class="c1"># There&#39;s no particular reason for these times, other than that they</span>
<span class="c1"># contain analysis-ready data</span>
<span class="n">segments</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mi">1240579783</span><span class="p">,</span> <span class="mi">1240587612</span><span class="p">),</span> 
    <span class="p">(</span><span class="mi">1240594562</span><span class="p">,</span> <span class="mi">1240606748</span><span class="p">),</span> 
    <span class="p">(</span><span class="mi">1240624412</span><span class="p">,</span> <span class="mi">1240644412</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">1240644412</span><span class="p">,</span> <span class="mi">1240654372</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">1240658942</span><span class="p">,</span> <span class="mi">1240668052</span><span class="p">),</span>
<span class="p">]</span>

<span class="k">for</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
    <span class="c1"># Download the data from GWOSC. This will take a few minutes.</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">background_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;background-</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">duration</span><span class="si">}</span><span class="s2">.hdf5&quot;</span>
    <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
        <span class="k">continue</span>

    <span class="n">ts_dict</span> <span class="o">=</span> <span class="n">TimeSeriesDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ifo</span> <span class="ow">in</span> <span class="n">ifos</span><span class="p">:</span>
        <span class="n">ts_dict</span><span class="p">[</span><span class="n">ifo</span><span class="p">]</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="o">.</span><span class="n">fetch_open_data</span><span class="p">(</span><span class="n">ifo</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ts_dict</span> <span class="o">=</span> <span class="n">ts_dict</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">sample_rate</span><span class="p">)</span>
    <span class="n">ts_dict</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;hdf5&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.transforms</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralDensity</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>

<span class="n">fftlength</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">spectral_density</span> <span class="o">=</span> <span class="n">SpectralDensity</span><span class="p">(</span>
    <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">fftlength</span><span class="o">=</span><span class="n">fftlength</span><span class="p">,</span>
    <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">average</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
<span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="c1"># This is H1 and L1 data from O3 that I downloaded earlier</span>
<span class="c1"># We have tools for dataloading that I&#39;ll get to later</span>
<span class="n">background_file</span> <span class="o">=</span> <span class="n">background_dir</span> <span class="o">/</span> <span class="s2">&quot;background-1240579783-7829.hdf5&quot;</span>
<span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">background_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">background</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">ifo</span><span class="p">][:])</span> <span class="k">for</span> <span class="n">ifo</span> <span class="ow">in</span> <span class="n">ifos</span><span class="p">]</span>
    <span class="n">background</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">background</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="c1"># Note cast to double</span>
<span class="n">psd</span> <span class="o">=</span> <span class="n">spectral_density</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">double</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.Size([2, 2049])
</pre></div>
</div>
</div>
</div>
<p>We can plot the PSDs and see that they look as expected:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">freqs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nyquist</span><span class="p">,</span> <span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span><span class="o">.</span><span class="n">cpu</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;H1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span><span class="o">.</span><span class="n">cpu</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;L1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;PSD (1/Hz)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/83ca7181a7cb361be5c27bde71a9c67cd0c7a62edaa20eb66f2d6b5f3a5a8daa.png" src="../_images/83ca7181a7cb361be5c27bde71a9c67cd0c7a62edaa20eb66f2d6b5f3a5a8daa.png" />
</div>
</div>
</section>
<section id="snr-calculation">
<h3>SNR Calculation<a class="headerlink" href="#snr-calculation" title="Link to this heading"></a></h3>
<p>With the PSD from H1 and L1, we can calculate the SNRs of the waveforms we generated.</p>
<p>Note: the shape of the PSDs is determined by the sampling rate and the FFT length used in the calculation, and so may not match up with the shape of the FFT’ed waveforms. We can interpolate the PSDs so that the dimensions match.</p>
<p>Future feature:</p>
<ul class="simple">
<li><p>Do this interpolation automatically somewhere unless the user specifies otherwise</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.gw</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_ifo_snr</span><span class="p">,</span> <span class="n">compute_network_snr</span>

<span class="c1"># Note need to interpolate</span>
<span class="k">if</span> <span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">num_freqs</span><span class="p">:</span>
    <span class="c1"># Adding dummy dimensions for consistency</span>
    <span class="k">while</span> <span class="n">psd</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">psd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
        <span class="n">psd</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_freqs</span><span class="p">,),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span>
    <span class="p">)</span>

<span class="c1"># We can compute both the individual and network SNRs</span>
<span class="c1"># The SNR calculation starts at the minimum frequency we</span>
<span class="c1"># specified earlier and goes to the maximum</span>
<span class="c1"># TODO: There&#39;s probably no reason to have multiple functions</span>
<span class="n">h1_snr</span> <span class="o">=</span> <span class="n">compute_ifo_snr</span><span class="p">(</span>
    <span class="n">responses</span><span class="o">=</span><span class="n">waveforms</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">highpass</span><span class="o">=</span><span class="n">f_min</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">l1_snr</span> <span class="o">=</span> <span class="n">compute_ifo_snr</span><span class="p">(</span>
    <span class="n">responses</span><span class="o">=</span><span class="n">waveforms</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">highpass</span><span class="o">=</span><span class="n">f_min</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">network_snr</span> <span class="o">=</span> <span class="n">compute_network_snr</span><span class="p">(</span>
    <span class="n">responses</span><span class="o">=</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">highpass</span><span class="o">=</span><span class="n">f_min</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s plot histograms of each of these SNR arrays:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">h1_snr</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;H1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">l1_snr</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;L1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">network_snr</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Network&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;SNR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Count&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/64c1c99b6ff40e8cc7394c785b72af0098833bcc84f529ecdc4b9604de484ff8.png" src="../_images/64c1c99b6ff40e8cc7394c785b72af0098833bcc84f529ecdc4b9604de484ff8.png" />
</div>
</div>
<p>This looks more or less like expected. But we’ve got a lot of low SNR signals, which a search will have trouble detecting. We can rescale our waveforms so that the SNR distribution is more favorable. This could be useful for something like curriculum learning: your network could begin with higher SNR events, and slowly be shown lower SNR events as training continues.</p>
<p>We’ll create an array of target SNRs based on a power law distribution that very roughly matches the above, but with a minimum SNR of 12 and maximum of 100.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.gw</span><span class="w"> </span><span class="kn">import</span> <span class="n">reweight_snrs</span>

<span class="n">target_snrs</span> <span class="o">=</span> <span class="n">PowerLaw</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">num_waveforms</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="c1"># Each waveform will be scaled by the ratio of its target SNR to its current SNR</span>
<span class="n">waveforms</span> <span class="o">=</span> <span class="n">reweight_snrs</span><span class="p">(</span>
    <span class="n">responses</span><span class="o">=</span><span class="n">waveforms</span><span class="p">,</span>
    <span class="n">target_snrs</span><span class="o">=</span><span class="n">target_snrs</span><span class="p">,</span>
    <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">highpass</span><span class="o">=</span><span class="n">f_min</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">network_snr</span> <span class="o">=</span> <span class="n">compute_network_snr</span><span class="p">(</span>
    <span class="n">responses</span><span class="o">=</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">highpass</span><span class="o">=</span><span class="n">f_min</span>
<span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">network_snr</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Network&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;SNR&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Count&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/70cb6d178bf84e76f9ccb10e8f32d953948f78a6fb6f558d0a3ee494e39574fd.png" src="../_images/70cb6d178bf84e76f9ccb10e8f32d953948f78a6fb6f558d0a3ee494e39574fd.png" />
</div>
</div>
<p>We now have a set of waveforms that are much easier to detect.</p>
</section>
</section>
<section id="dataloading">
<h2>Dataloading<a class="headerlink" href="#dataloading" title="Link to this heading"></a></h2>
<p>When training a model, it’s beneficial to provide as much variety in data as you can. We benefit from having multiple independent detectors, which allows for combinatorially more background samples than a single detector would, as the samples don’t have to be coincident.</p>
<p>The <a class="reference external" href="https://github.com/ML4GW/ml4gw/blob/6c68f4bade88362d5d6d27e912410a84765d09a0/ml4gw/dataloading/hdf5_dataset.py#L15"><code class="docutils literal notranslate"><span class="pre">Hdf5TimeSeriesDataset</span></code></a> allows for randomly sampling windows of data from hdf5 files, provided they all have the same structure. Here, we have a set of background files, each containing H1 and L1 strain data. We could chop this data up into samples prior to training, but we’d be limited by the number of samples we could create and fit on disk. Instead, during training, we grab the data we need for each batch by randomly sampling from all of these files, giving us effectively unlimited background data to train on.</p>
<p>Future feature:</p>
<ul class="simple">
<li><p>Allow sampling from multiple datasets within the same file</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>ls<span class="w"> </span>data/background_data/
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>background-1240579783-7829.hdf5   background-1240644412-9960.hdf5
background-1240594562-12186.hdf5  background-1240658942-9110.hdf5
background-1240624412-20000.hdf5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.dataloading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Hdf5TimeSeriesDataset</span>

<span class="c1"># Defining some parameters for future use, and to</span>
<span class="c1"># determine the size of the windows to sample.</span>
<span class="c1"># We&#39;re going to be whitening the last part of each</span>
<span class="c1"># window with a PSD calculated from the first part,</span>
<span class="c1"># so we need to grab enough data to do that</span>

<span class="c1"># Length of data used to estimate PSD</span>
<span class="n">psd_length</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">psd_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">psd_length</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>

<span class="c1"># Length of filter. A segment of length fduration / 2</span>
<span class="c1"># will be cropped from either side after whitening</span>
<span class="n">fduration</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Length of window of data we&#39;ll feed to our network</span>
<span class="n">kernel_length</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">kernel_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>

<span class="c1"># Total length of data to sample</span>
<span class="n">window_length</span> <span class="o">=</span> <span class="n">psd_length</span> <span class="o">+</span> <span class="n">fduration</span> <span class="o">+</span> <span class="n">kernel_length</span>

<span class="n">fnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">background_dir</span><span class="o">.</span><span class="n">iterdir</span><span class="p">())</span>
<span class="n">dataloader</span> <span class="o">=</span> <span class="n">Hdf5TimeSeriesDataset</span><span class="p">(</span>
    <span class="n">fnames</span><span class="o">=</span><span class="n">fnames</span><span class="p">,</span>
    <span class="n">channels</span><span class="o">=</span><span class="n">ifos</span><span class="p">,</span>
    <span class="n">kernel_size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">window_length</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">),</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">2</span>
    <span class="o">*</span> <span class="n">num_waveforms</span><span class="p">,</span>  <span class="c1"># Grab twice as many background samples as we have waveforms</span>
    <span class="n">batches_per_epoch</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Just doing 1 here for demonstration purposes</span>
    <span class="n">coincident</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">background_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">background_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>torch.Size([1000, 2, 39936])
</pre></div>
</div>
</div>
</div>
</section>
<section id="whitening">
<h2>Whitening<a class="headerlink" href="#whitening" title="Link to this heading"></a></h2>
<p>It’s crucial to normalize your data before putting it through a neural network, and whitening provides a physically meaningful way of doing that. The <a class="reference external" href="https://github.com/ML4GW/ml4gw/blob/6c68f4bade88362d5d6d27e912410a84765d09a0/ml4gw/transforms/whitening.py#L15"><code class="docutils literal notranslate"><span class="pre">Whiten</span></code></a> module will whiten and optionally highpass batches of multi-channel data with a provided set of PSDs. If the tensor of PSDs is 2D, each batch element of data will be whitened using the same PSDs. If 3D, each batch element will be whitened by the PSDs contained along the 0th dimension. In other words, you can provide a single PSD for each channel to whiten all elements in that channel, or you can provide a PSD for each element. We’re doing the latter here.</p>
<p>Note that the whitening process automatically removes <code class="docutils literal notranslate"><span class="pre">fduration</span> <span class="pre">/</span> <span class="pre">2</span></code> seconds from either side of the input data.</p>
<p>Future feature:</p>
<ul class="simple">
<li><p>Add an option to not crop</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.transforms</span><span class="w"> </span><span class="kn">import</span> <span class="n">Whiten</span>

<span class="n">whiten</span> <span class="o">=</span> <span class="n">Whiten</span><span class="p">(</span>
    <span class="n">fduration</span><span class="o">=</span><span class="n">fduration</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">highpass</span><span class="o">=</span><span class="n">f_min</span>
<span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="c1"># Create PSDs using the first psd_length seconds of each sample</span>
<span class="c1"># with the SpectralDensity module we defined earlier</span>
<span class="n">psd</span> <span class="o">=</span> <span class="n">spectral_density</span><span class="p">(</span><span class="n">background_samples</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">psd_size</span><span class="p">]</span><span class="o">.</span><span class="n">double</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PSD shape: </span><span class="si">{</span><span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Take everything after the first psd_length as our input kernel</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">background_samples</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">psd_size</span><span class="p">:]</span>
<span class="c1"># And whiten using our PSDs</span>
<span class="n">whitened_kernel</span> <span class="o">=</span> <span class="n">whiten</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Kernel shape: </span><span class="si">{</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Whitened kernel shape: </span><span class="si">{</span><span class="n">whitened_kernel</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>PSD shape: torch.Size([1000, 2, 2049])
Kernel shape: torch.Size([1000, 2, 7168])
Whitened kernel shape: torch.Size([1000, 2, 3072])
</pre></div>
</div>
</div>
</div>
<p>Plotting the first segment of strain, we can see that the data looks as expected. For visual clarity, the plots show only H1 data. Again, note the difference in length before and after whitening.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kernel_length</span> <span class="o">+</span> <span class="n">fduration</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Strain&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">times</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kernel_length</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">whitened_kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Whitened strain&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/7d77df03ae075e16e9d8012da81165346934c500eb78a0a712923d827b38f54f.png" src="../_images/7d77df03ae075e16e9d8012da81165346934c500eb78a0a712923d827b38f54f.png" />
<img alt="../_images/c621d7d219820a7550a25bbe3c93a31efa083f1115aec0abd631f9fb5dbde4df.png" src="../_images/c621d7d219820a7550a25bbe3c93a31efa083f1115aec0abd631f9fb5dbde4df.png" />
</div>
</div>
<p>Next, we can add our waveforms into half of these background samples, taking care not to add them into data that will be removed during whitening. We’ll use only the final <code class="docutils literal notranslate"><span class="pre">kernel_length</span></code> seconds of each waveform.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fduration</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
<span class="n">injected</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
<span class="c1"># Inject waveforms into every other background sample</span>
<span class="n">injected</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span> <span class="o">+=</span> <span class="n">waveforms</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">kernel_size</span><span class="p">:]</span>
<span class="c1"># And whiten with the same PSDs as before</span>
<span class="n">whitened_injected</span> <span class="o">=</span> <span class="n">whiten</span><span class="p">(</span><span class="n">injected</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can plot one of these as well, using the loudest signal for visibility.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Factor of 2 because we injected every other sample</span>
<span class="n">idx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">network_snr</span><span class="p">)</span>

<span class="n">times</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kernel_length</span> <span class="o">+</span> <span class="n">fduration</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">injected</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Strain&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">times</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">kernel_length</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">whitened_injected</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Whitened strain&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/daa31e7eda2b36f7b0dd5643cc10418713ca3521bc64663f87a20a4f364a3014.png" src="../_images/daa31e7eda2b36f7b0dd5643cc10418713ca3521bc64663f87a20a4f364a3014.png" />
<img alt="../_images/50d0f46ea356faa9bfe813f86a9c3ad11c7ecd585ec6d220c8aa80b4a30dc5eb.png" src="../_images/50d0f46ea356faa9bfe813f86a9c3ad11c7ecd585ec6d220c8aa80b4a30dc5eb.png" />
</div>
</div>
<p>We’ll use this dataset we just created as a validation dataset during the training example, so I’ll create a tensor of labels and save everything to file.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">injected</span><span class="p">))</span>
<span class="n">y</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">data_dir</span> <span class="o">/</span> <span class="s2">&quot;validation_dataset.hdf5&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">whitened_injected</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
    <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="transforms">
<h2>Transforms<a class="headerlink" href="#transforms" title="Link to this heading"></a></h2>
<p>If we wanted to, we could stop with our data as-is and train a time-domain model (which is what we’ll do in the example). But we could also transform our data into the time-frequency domain to create spectrograms, and treat this as an image classification problem. <code class="docutils literal notranslate"><span class="pre">ml4gw</span></code> has two methods for doing that: the <a class="reference external" href="https://github.com/ML4GW/ml4gw/blob/6c68f4bade88362d5d6d27e912410a84765d09a0/ml4gw/transforms/spectrogram.py#L13"><code class="docutils literal notranslate"><span class="pre">MultiResolutionSpectrogram</span></code></a> and the <a class="reference external" href="https://github.com/ML4GW/ml4gw/blob/6c68f4bade88362d5d6d27e912410a84765d09a0/ml4gw/transforms/qtransform.py#L154"><code class="docutils literal notranslate"><span class="pre">Q-transform</span></code></a>.</p>
<p>The multi-resolution spectrogram module creates a single spectrogram by combining multiple spectrograms that were calculated using different numbers of FFTs. This is similar to what PySTAMPAS does as part of their pipeline. The Q-transform is a translation of GWpy’s implementation, with some torch-specific speed-ups.</p>
<p>The spectrogram module uses torchaudio’s <a class="reference external" href="https://pytorch.org/audio/main/generated/torchaudio.transforms.Spectrogram.html"><code class="docutils literal notranslate"><span class="pre">Spectrogram</span></code></a> object, and can accept any of the same keyword arguments, given in a list.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.transforms</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">MultiResolutionSpectrogram</span><span class="p">,</span>
    <span class="n">QScan</span><span class="p">,</span>
    <span class="n">SingleQTransform</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">mrs</span> <span class="o">=</span> <span class="n">MultiResolutionSpectrogram</span><span class="p">(</span>
    <span class="n">kernel_length</span><span class="o">=</span><span class="n">kernel_length</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="p">[</span>
        <span class="mi">64</span><span class="p">,</span>
        <span class="mi">128</span><span class="p">,</span>
        <span class="mi">256</span><span class="p">,</span>
    <span class="p">],</span>  <span class="c1"># Specififying just one value will create a single-resolution spectrogram</span>
<span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="c1"># The Q-transform can be accessed either through the QScan,</span>
<span class="c1"># which will look over a range of q values, or through the</span>
<span class="c1"># SingleQTransform, which uses a given q value</span>
<span class="n">qscan</span> <span class="o">=</span> <span class="n">QScan</span><span class="p">(</span>
    <span class="n">duration</span><span class="o">=</span><span class="n">kernel_length</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">spectrogram_shape</span><span class="o">=</span><span class="p">[</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">],</span>
    <span class="n">qrange</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">128</span><span class="p">],</span>
<span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="n">sqt</span> <span class="o">=</span> <span class="n">SingleQTransform</span><span class="p">(</span>
    <span class="n">duration</span><span class="o">=</span><span class="n">kernel_length</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">spectrogram_shape</span><span class="o">=</span><span class="p">[</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">],</span>
    <span class="n">q</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
<span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We’ll pass our whitened and injected data to each of these transforms, which will process the entire batch at once, and plot the first sample.</p>
<p>Note: the axes on each plot correspond to a bin index, not the actual time and frequency</p>
<p>Note: the multi-resolution spectrogram has linearly-spaced frequency bins, while the Q-transform has log-spaced bins</p>
<p>Neither of these aspects are really a problem for training a model (all that really matters is that you treat all your data the same way), but it’s annoying when it comes to making plots.</p>
<p>Future features:</p>
<ul class="simple">
<li><p>Store the time and frequency values corresponding to each bin as attributes of the object</p></li>
<li><p>Allow either frequency bin spacing</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">specgram</span> <span class="o">=</span> <span class="n">mrs</span><span class="p">(</span><span class="n">whitened_injected</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">specgram</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/c01f5af8db0dd3c5a206c1504a03c8a00c7ee93862acdc9657db305e55ce1adb.png" src="../_images/c01f5af8db0dd3c5a206c1504a03c8a00c7ee93862acdc9657db305e55ce1adb.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">specgram</span> <span class="o">=</span> <span class="n">qscan</span><span class="p">(</span><span class="n">whitened_injected</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">specgram</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/d8c72a7cb0e1223668cb751b40f29b33626abc773f549b8bfdf66bfc91f1b007.png" src="../_images/d8c72a7cb0e1223668cb751b40f29b33626abc773f549b8bfdf66bfc91f1b007.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">specgram</span> <span class="o">=</span> <span class="n">sqt</span><span class="p">(</span><span class="n">whitened_injected</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">specgram</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">aspect</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/125dc6158f59b8ba54ccf9b3b514e12c7cd5a33ba13c79a9d70972a44d193b43.png" src="../_images/125dc6158f59b8ba54ccf9b3b514e12c7cd5a33ba13c79a9d70972a44d193b43.png" />
</div>
</div>
<p>The big benefit here is <em>speed</em>. We computed 2,000 Q-transforms in a fraction of a second. The downside is that we needed to use the same q value for each of them, but there are applications where that may not be a problem. For instance, BBH signals are typically better represented with lower q values.</p>
<p>There are other <a class="reference external" href="https://github.com/ML4GW/ml4gw/tree/main/ml4gw/transforms">transforms</a> that I don’t have time to go into:</p>
<ul class="simple">
<li><p>Channel-wise scaler</p></li>
<li><p>Spline interpolation (though note the caveats)</p></li>
<li><p>Fixed whitener, which is fit to a set PSD</p></li>
<li><p>Pearson correlation calculator</p></li>
</ul>
<p>Future features:</p>
<ul class="simple">
<li><p>Fix edge effects of spline interpolation</p></li>
<li><p>Multi-rate resampling</p></li>
</ul>
</section>
<section id="architectures">
<h2>Architectures<a class="headerlink" href="#architectures" title="Link to this heading"></a></h2>
<p>We’ve implemented a couple basic <a class="reference external" href="https://github.com/ML4GW/ml4gw/tree/main/ml4gw/nn">neural network architectures</a> for out-of-the-box convenience. Today, we’ll be using a 1D ResNet, which is mostly copied from PyTorch’s implementation, but with a few key differences:</p>
<ul class="simple">
<li><p>Arbitrary kernel sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GroupNorm</span></code> as the default normalization layer, as training statistics in general won’t match testing statistics</p></li>
<li><p>Custom <code class="docutils literal notranslate"><span class="pre">GroupNorm</span></code> implementation which is faster than the standard PyTorch version at inference time</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.nn.resnet</span><span class="w"> </span><span class="kn">import</span> <span class="n">ResNet1D</span>

<span class="n">architecture</span> <span class="o">=</span> <span class="n">ResNet1D</span><span class="p">(</span>
    <span class="n">in_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># H1 and L1 as input channels</span>
    <span class="n">layers</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  <span class="c1"># Keep things small and do a ResNet10</span>
    <span class="n">classes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Single scalar-valued output</span>
    <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>  <span class="c1"># Size of convolutional kernels, not to be confused with data size</span>
<span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="c1"># And we can, e.g., pass the first element of our validation set</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">architecture</span><span class="p">(</span><span class="n">whitened_injected</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tensor([[-0.3213]], device=&#39;cuda:0&#39;)
</pre></div>
</div>
</div>
</div>
</section>
<section id="example-training-setup">
<h2>Example training setup<a class="headerlink" href="#example-training-setup" title="Link to this heading"></a></h2>
<p>We’ll now go through an example of putting many of these pieces together into a single model, implemented using th <a class="reference external" href="https://lightning.ai/docs/pytorch/stable/">PyTorch Lightning</a> framework.</p>
<p>Begin by clearing the GPU:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">gc</span>

<span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">empty_cache</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">reset_peak_memory_stats</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw</span><span class="w"> </span><span class="kn">import</span> <span class="n">augmentations</span><span class="p">,</span> <span class="n">distributions</span><span class="p">,</span> <span class="n">gw</span><span class="p">,</span> <span class="n">transforms</span><span class="p">,</span> <span class="n">waveforms</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.dataloading</span><span class="w"> </span><span class="kn">import</span> <span class="n">ChunkedTimeSeriesDataset</span><span class="p">,</span> <span class="n">Hdf5TimeSeriesDataset</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ml4gw.utils.slicing</span><span class="w"> </span><span class="kn">import</span> <span class="n">sample_kernels</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">lightning</span><span class="w"> </span><span class="kn">import</span> <span class="n">pytorch</span> <span class="k">as</span> <span class="n">pl</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torchmetrics</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchmetrics.classification</span><span class="w"> </span><span class="kn">import</span> <span class="n">BinaryAUROC</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Ml4gwDetectionModel</span><span class="p">(</span><span class="n">pl</span><span class="o">.</span><span class="n">LightningModule</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Model with methods for generating waveforms and</span>
<span class="sd">    performing our preprocessing augmentations in</span>
<span class="sd">    real-time on the GPU. Also loads training background</span>
<span class="sd">    in chunks from disk, then samples batches from chunks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">architecture</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="n">torchmetrics</span><span class="o">.</span><span class="n">Metric</span><span class="p">,</span>
        <span class="n">ifos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;H1&quot;</span><span class="p">,</span> <span class="s2">&quot;L1&quot;</span><span class="p">],</span>
        <span class="n">kernel_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span>
        <span class="c1"># PSD/whitening args</span>
        <span class="n">fduration</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">psd_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
        <span class="n">fftlength</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">highpass</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
        <span class="c1"># Dataloading args</span>
        <span class="n">chunk_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>  <span class="c1"># we&#39;ll talk about chunks in a second</span>
        <span class="n">reads_per_chunk</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
        <span class="n">learning_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
        <span class="c1"># Waveform generation args</span>
        <span class="n">waveform_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">approximant</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">cbc</span><span class="o">.</span><span class="n">IMRPhenomD</span><span class="p">,</span>
        <span class="n">param_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">Distribution</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">,</span>
        <span class="n">waveform_duration</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">f_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">f_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">f_ref</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="c1"># Augmentation args</span>
        <span class="n">inversion_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">reversal_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">min_snr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
        <span class="n">max_snr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_hyperparameters</span><span class="p">(</span>
            <span class="n">ignore</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;architecture&quot;</span><span class="p">,</span> <span class="s2">&quot;metric&quot;</span><span class="p">,</span> <span class="s2">&quot;approximant&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nn</span> <span class="o">=</span> <span class="n">architecture</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inverter</span> <span class="o">=</span> <span class="n">augmentations</span><span class="o">.</span><span class="n">SignalInverter</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="n">inversion_prob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverser</span> <span class="o">=</span> <span class="n">augmentations</span><span class="o">.</span><span class="n">SignalReverser</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="n">reversal_prob</span><span class="p">)</span>

        <span class="c1"># real-time transformations defined with torch Modules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral_density</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">SpectralDensity</span><span class="p">(</span>
            <span class="n">sample_rate</span><span class="p">,</span> <span class="n">fftlength</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whitener</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Whiten</span><span class="p">(</span>
            <span class="n">fduration</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">highpass</span><span class="o">=</span><span class="n">highpass</span>
        <span class="p">)</span>

        <span class="c1"># get some geometry information about</span>
        <span class="c1"># the interferometers we&#39;re going to project to</span>
        <span class="n">detector_tensors</span><span class="p">,</span> <span class="n">vertices</span> <span class="o">=</span> <span class="n">gw</span><span class="o">.</span><span class="n">get_ifo_geometry</span><span class="p">(</span><span class="o">*</span><span class="n">ifos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;detector_tensors&quot;</span><span class="p">,</span> <span class="n">detector_tensors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;detector_vertices&quot;</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>

        <span class="c1"># define some sky parameter distributions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span> <span class="o">=</span> <span class="n">param_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dec</span> <span class="o">=</span> <span class="n">distributions</span><span class="o">.</span><span class="n">Cosine</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">Uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">Uniform</span><span class="p">(</span>
            <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">pi</span>
        <span class="p">)</span>  <span class="c1"># relative RAs of detector and source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">waveform_generator</span> <span class="o">=</span> <span class="n">TimeDomainCBCWaveformGenerator</span><span class="p">(</span>
            <span class="n">approximant</span><span class="o">=</span><span class="n">approximant</span><span class="p">(),</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">duration</span><span class="o">=</span><span class="n">waveform_duration</span><span class="p">,</span>
            <span class="n">f_min</span><span class="o">=</span><span class="n">f_min</span><span class="p">,</span>
            <span class="n">f_ref</span><span class="o">=</span><span class="n">f_ref</span><span class="p">,</span>
            <span class="n">right_pad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># rather than sample distances, we&#39;ll sample target SNRs.</span>
        <span class="c1"># This way we can ensure we train our network on</span>
        <span class="c1"># signals that are more detectable. We&#39;ll use a distribution</span>
        <span class="c1"># that looks roughly like the natural sampled SNR distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr</span> <span class="o">=</span> <span class="n">distributions</span><span class="o">.</span><span class="n">PowerLaw</span><span class="p">(</span><span class="n">min_snr</span><span class="p">,</span> <span class="n">max_snr</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># up front let&#39;s define some properties in units of samples</span>
        <span class="c1"># Note the different usage of window_size from earlier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kernel_length</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">fduration</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psd_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">psd_length</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nn</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">training_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">):</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">batch</span>
        <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">binary_cross_entropy_with_logits</span><span class="p">(</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;train_loss&quot;</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">on_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prog_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loss</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">):</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">batch</span>
        <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;valid_auroc&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="n">on_epoch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prog_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">configure_optimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">parameters</span><span class="p">()</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">AdamW</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
        <span class="n">scheduler</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">OneCycleLR</span><span class="p">(</span>
            <span class="n">optimizer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
            <span class="n">pct_start</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">total_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trainer</span><span class="o">.</span><span class="n">estimated_stepping_batches</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">scheduler_config</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">scheduler</span><span class="o">=</span><span class="n">scheduler</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="s2">&quot;step&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">lr_scheduler</span><span class="o">=</span><span class="n">scheduler_config</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">configure_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">chkpt</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">ModelCheckpoint</span><span class="p">(</span><span class="n">monitor</span><span class="o">=</span><span class="s2">&quot;valid_auroc&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chkpt</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="n">rvs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">rvs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">waveform_prob</span>
        <span class="n">num_injections</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">num_injections</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="n">params</span><span class="p">[</span><span class="s2">&quot;s1z&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;s2z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;chi1&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;chi2&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">params</span><span class="p">[</span><span class="s2">&quot;mass_1&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;mass_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">conversion</span><span class="o">.</span><span class="n">chirp_mass_and_mass_ratio_to_components</span><span class="p">(</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;chirp_mass&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;mass_ratio&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">hc</span><span class="p">,</span> <span class="n">hp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">waveform_generator</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hc</span><span class="p">,</span> <span class="n">hp</span><span class="p">,</span> <span class="n">mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">project_waveforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">hc</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">hp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="c1"># sample sky parameters</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hc</span><span class="p">)</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hc</span><span class="p">)</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hc</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">hc</span><span class="p">)</span>

        <span class="c1"># project to interferometer response</span>
        <span class="k">return</span> <span class="n">gw</span><span class="o">.</span><span class="n">compute_observed_strain</span><span class="p">(</span>
            <span class="n">dec</span><span class="o">=</span><span class="n">dec</span><span class="p">,</span>
            <span class="n">psi</span><span class="o">=</span><span class="n">psi</span><span class="p">,</span>
            <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span>
            <span class="n">detector_tensors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">detector_tensors</span><span class="p">,</span>
            <span class="n">detector_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">detector_vertices</span><span class="p">,</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">cross</span><span class="o">=</span><span class="n">hc</span><span class="p">,</span>
            <span class="n">plus</span><span class="o">=</span><span class="n">hp</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">rescale_snrs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">responses</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">psd</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="c1"># make sure everything has the same number of frequency bins</span>
        <span class="n">num_freqs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">responses</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">psd</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_freqs</span><span class="p">:</span>
            <span class="n">psd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
                <span class="n">psd</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_freqs</span><span class="p">,),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span>
            <span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">responses</span><span class="p">)</span>
        <span class="n">target_snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="o">.</span><span class="n">sample</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">responses</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gw</span><span class="o">.</span><span class="n">reweight_snrs</span><span class="p">(</span>
            <span class="n">responses</span><span class="o">=</span><span class="n">responses</span><span class="o">.</span><span class="n">double</span><span class="p">(),</span>
            <span class="n">target_snrs</span><span class="o">=</span><span class="n">target_snrs</span><span class="p">,</span>
            <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span>
            <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
            <span class="n">highpass</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">highpass</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sample_waveforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">responses</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="c1"># slice off random views of each waveform to inject in arbitrary positions</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="n">responses</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="p">:]</span>

        <span class="c1"># pad so that at least half the kernel always contains signals</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">responses</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sample_kernels</span><span class="p">(</span><span class="n">responses</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="n">coincident</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">augment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
        <span class="c1"># break off &quot;background&quot; from target kernel and compute its PSD</span>
        <span class="c1"># (in double precision since our scale is so small)</span>
        <span class="n">background</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="n">X</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">psd_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">double</span><span class="p">())</span>

        <span class="c1"># Generate at most batch_size signals from our parameter distributions</span>
        <span class="c1"># Keep a mask that indicates which rows to inject in</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hc</span><span class="p">,</span> <span class="n">hp</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_waveforms</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">hc</span><span class="p">,</span> <span class="n">hp</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">hc</span><span class="p">,</span> <span class="n">hp</span><span class="p">,</span> <span class="n">mask</span>

        <span class="c1"># Augment with inversion and reversal</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverter</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverser</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># sample sky parameters and project to responses, then</span>
        <span class="c1"># rescale the response according to a randomly sampled SNR</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_waveforms</span><span class="p">(</span><span class="n">hc</span><span class="p">,</span> <span class="n">hp</span><span class="p">)</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_snrs</span><span class="p">(</span><span class="n">responses</span><span class="p">,</span> <span class="n">psd</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>

        <span class="c1"># randomly slice out a window of the waveform, add it</span>
        <span class="c1"># to our background, then whiten everything</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_waveforms</span><span class="p">(</span><span class="n">responses</span><span class="p">)</span>
        <span class="n">X</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">responses</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whitener</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span>

        <span class="c1"># create labels, marking 1s where we injected</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">on_after_batch_transfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="c1"># this is a parent method that lightning calls</span>
        <span class="c1"># between when the batch gets moved to GPU and</span>
        <span class="c1"># when it gets passed to the training_step.</span>
        <span class="c1"># Apply our augmentations here</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainer</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
            <span class="n">batch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augment</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">batch</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">train_dataloader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Because our entire training dataset is generated</span>
        <span class="c1"># on the fly, the traditional idea of an &quot;epoch&quot;</span>
        <span class="c1"># meaning one pass through the training set doesn&#39;t</span>
        <span class="c1"># apply here. Instead, we have to set the number</span>
        <span class="c1"># of batches per epoch ourselves, which really</span>
        <span class="c1"># just amounts to deciding how often we want</span>
        <span class="c1"># to run over the validation dataset.</span>
        <span class="n">samples_per_epoch</span> <span class="o">=</span> <span class="mi">3000</span>
        <span class="n">batches_per_epoch</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">((</span><span class="n">samples_per_epoch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">batches_per_chunk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">batches_per_epoch</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">chunks_per_epoch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">batches_per_epoch</span> <span class="o">//</span> <span class="n">batches_per_chunk</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Hdf5TimeSeries dataset samples batches from disk.</span>
        <span class="c1"># In this instance, we&#39;ll make our batches really large so that</span>
        <span class="c1"># we can treat them as chunks to sample training batches from</span>
        <span class="n">fnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">background_dir</span><span class="o">.</span><span class="n">iterdir</span><span class="p">())</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">Hdf5TimeSeriesDataset</span><span class="p">(</span>
            <span class="n">fnames</span><span class="o">=</span><span class="n">fnames</span><span class="p">,</span>
            <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">ifos</span><span class="p">,</span>
            <span class="n">kernel_size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">chunk_length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">sample_rate</span>
            <span class="p">),</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">reads_per_chunk</span><span class="p">,</span>
            <span class="n">batches_per_epoch</span><span class="o">=</span><span class="n">chunks_per_epoch</span><span class="p">,</span>
            <span class="n">coincident</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># sample batches to pass to our NN from the chunks loaded from disk</span>
        <span class="k">return</span> <span class="n">ChunkedTimeSeriesDataset</span><span class="p">(</span>
            <span class="n">dataset</span><span class="p">,</span>
            <span class="n">kernel_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd_size</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">batches_per_chunk</span><span class="o">=</span><span class="n">batches_per_chunk</span><span class="p">,</span>
            <span class="n">coincident</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">val_dataloader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">data_dir</span> <span class="o">/</span> <span class="s2">&quot;validation_dataset.hdf5&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">][:])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">][:])</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">TensorDataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
            <span class="n">dataset</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hparams</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
            <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">pin_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">architecture</span> <span class="o">=</span> <span class="n">ResNet1D</span><span class="p">(</span>
    <span class="n">in_channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">layers</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="n">classes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="n">max_fpr</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="n">metric</span> <span class="o">=</span> <span class="n">BinaryAUROC</span><span class="p">(</span><span class="n">max_fpr</span><span class="o">=</span><span class="n">max_fpr</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">Ml4gwDetectionModel</span><span class="p">(</span>
    <span class="n">architecture</span><span class="o">=</span><span class="n">architecture</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">log_dir</span> <span class="o">=</span> <span class="n">data_dir</span> <span class="o">/</span> <span class="s2">&quot;logs&quot;</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">loggers</span><span class="o">.</span><span class="n">CSVLogger</span><span class="p">(</span><span class="n">log_dir</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ml4gw-expt&quot;</span><span class="p">)</span>
<span class="n">trainer</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">Trainer</span><span class="p">(</span>
    <span class="n">max_epochs</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="s2">&quot;16-mixed&quot;</span><span class="p">,</span>
    <span class="n">log_every_n_steps</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
    <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">pl</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">RichProgressBar</span><span class="p">()],</span>
    <span class="n">accelerator</span><span class="o">=</span><span class="s2">&quot;gpu&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">trainer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Trainer will use only 1 of 8 GPUs because it is running inside an interactive / notebook environment. You may try to set `Trainer(devices=8)` but please note that multi-GPU inside interactive / notebook environments is considered experimental and unstable. Your mileage may vary.
Using 16bit Automatic Mixed Precision (AMP)
GPU available: True (cuda), used: True
TPU available: False, using: 0 TPU cores
HPU available: False, using: 0 HPUs
The following callbacks returned in `LightningModule.configure_callbacks` will override existing callbacks passed to Trainer: ModelCheckpoint
LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1,2,3,4,5,6,7]
Loading `train_dataloader` to estimate number of stepping batches.
</pre></div>
</div>
<div class="output text_html"><pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace">┏━━━┳━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━┓
┃<span style="color: #800080; text-decoration-color: #800080; font-weight: bold">   </span>┃<span style="color: #800080; text-decoration-color: #800080; font-weight: bold"> Name               </span>┃<span style="color: #800080; text-decoration-color: #800080; font-weight: bold"> Type                           </span>┃<span style="color: #800080; text-decoration-color: #800080; font-weight: bold"> Params </span>┃<span style="color: #800080; text-decoration-color: #800080; font-weight: bold"> Mode  </span>┃
┡━━━╇━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━┩
│<span style="color: #7f7f7f; text-decoration-color: #7f7f7f"> 0 </span>│ nn                 │ ResNet1D                       │  232 K │ train │
│<span style="color: #7f7f7f; text-decoration-color: #7f7f7f"> 1 </span>│ metric             │ BinaryAUROC                    │      0 │ train │
│<span style="color: #7f7f7f; text-decoration-color: #7f7f7f"> 2 </span>│ inverter           │ SignalInverter                 │      0 │ train │
│<span style="color: #7f7f7f; text-decoration-color: #7f7f7f"> 3 </span>│ reverser           │ SignalReverser                 │      0 │ train │
│<span style="color: #7f7f7f; text-decoration-color: #7f7f7f"> 4 </span>│ spectral_density   │ SpectralDensity                │      0 │ train │
│<span style="color: #7f7f7f; text-decoration-color: #7f7f7f"> 5 </span>│ whitener           │ Whiten                         │      0 │ train │
│<span style="color: #7f7f7f; text-decoration-color: #7f7f7f"> 6 </span>│ waveform_generator │ TimeDomainCBCWaveformGenerator │      0 │ train │
└───┴────────────────────┴────────────────────────────────┴────────┴───────┘
</pre>
</div><div class="output text_html"><pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"><span style="font-weight: bold">Trainable params</span>: 232 K                                                                                            
<span style="font-weight: bold">Non-trainable params</span>: 0                                                                                            
<span style="font-weight: bold">Total params</span>: 232 K                                                                                                
<span style="font-weight: bold">Total estimated model params size (MB)</span>: 0                                                                          
<span style="font-weight: bold">Modules in train mode</span>: 45                                                                                          
<span style="font-weight: bold">Modules in eval mode</span>: 0                                                                                            
</pre>
</div><script type="application/vnd.jupyter.widget-view+json">{"model_id": "6572d6f8806b449a82cd68a48bee997b", "version_major": 2, "version_minor": 0}</script><div class="output text_html"><pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace">/home/william.benoit/ML4GW/ml4gw/.venv/lib/python3.10/site-packages/lightning/pytorch/trainer/connectors/data_conne
ctor.py:424: The 'val_dataloader' does not have many workers which may be a bottleneck. Consider increasing the 
value of the `num_workers` argument` to `num_workers=79` in the `DataLoader` to improve performance.
</pre>
</div><div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>`Trainer.fit` stopped: `max_epochs=30` reached.
</pre></div>
</div>
<div class="output text_html"><pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"></pre>
</div></div>
</div>
<p>We can now plot the metrics from our run and see the results:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">csv</span>

<span class="n">path</span> <span class="o">=</span> <span class="n">log_dir</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;ml4gw-expt&quot;</span><span class="p">)</span>
<span class="c1"># Take the most recent run, if we&#39;ve done multiple</span>
<span class="n">versions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">iterdir</span><span class="p">()]</span>
<span class="n">version</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">versions</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;version_</span><span class="si">{</span><span class="n">version</span><span class="si">}</span><span class="s2">/metrics.csv&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="n">train_steps</span><span class="p">,</span> <span class="n">train_loss</span><span class="p">,</span> <span class="n">valid_steps</span><span class="p">,</span> <span class="n">valid_loss</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">train_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">train_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">valid_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">train_steps</span><span class="p">,</span> <span class="n">train_loss</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Train loss&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">valid_steps</span><span class="p">,</span> <span class="n">valid_loss</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Validation AUROC&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Step&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Metric value&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/56465eba5df86a054809ada0bdcc1a9fb183275754ed757f89f44a5a5ece6402.png" src="../_images/56465eba5df86a054809ada0bdcc1a9fb183275754ed757f89f44a5a5ece6402.png" />
</div>
</div>
<p>As we’d hope, the training loss decreases and the validation AUROC approaches 1.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../examples/transforms.whitening.html" class="btn btn-neutral float-left" title="Whitening" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ml4gw_lfi_tutorial.html" class="btn btn-neutral float-right" title="Tutorial on distribution approximation and posterior estimation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Ethan Marx &lt;emarx@mit.edu&gt;, Will Benoit &lt;benoi090@umn.edu&gt;, Deep Chatterjee &lt;deep1018@mit.edu&gt;.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>